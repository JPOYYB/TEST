<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>ボス確認用</title>
    <style>
        body { margin: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background: #222; color: white; font-family: sans-serif; flex-direction: column;}
        canvas { background: #87CEEB; border: 2px solid #555; }
        #status { margin-top: 10px; font-size: 20px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas" width="800" height="400"></canvas>
    <div id="status">テストモード：ボスを目の前に配置しました</div>

<script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // 画像の準備（読み込みに失敗してもゲームが止まらないようにしています）
    const playerImg = new Image(); playerImg.src = "icon1.jpg";
    const blockImg = new Image();  blockImg.src = "icon2.jpg";
    const enemyImg = new Image();  enemyImg.src = "icon3.jpg";
    
    // 画像が読み込まれたかどうかのフラグ
    let enemyImgLoaded = false;
    enemyImg.onload = () => { enemyImgLoaded = true; };

    const statusDiv = document.getElementById("status");

    // --- ゲーム設定 ---
    let gameState = "playing";
    let cameraX = 0;
    const STAGE_WIDTH = 2000;

    const player = { x: 50, y: 200, width: 30, height: 30, dx: 0, dy: 0, speed: 5, jumpPower: -13, gravity: 0.6, grounded: false };

    const platforms = [
        { x: 0, y: 350, w: 2000, h: 50, color: "green" },
        { x: 200, y: 250, w: 100, h: 20, color: "brown" }, // 最初の足場
        { x: 600, y: 200, w: 100, h: 20, color: "brown" }
    ];

    // ★修正点：ボスをスタート地点のすぐ近く(x:500)に配置しました★
    let boss = {
        x: 500, y: 270,         // スタートしてすぐの位置
        width: 80, height: 80, 
        dx: 2, hp: 3, alive: true, invulnerable: 0, 
        isActive: true,         // 最初から動くように変更
        startX: 400, endX: 700  // 移動範囲も手前に変更
    };

    const keys = {};
    window.addEventListener("keydown", (e) => {
        keys[e.code] = true;
        if (gameState !== "playing" && e.code === "Space") resetGame();
    });
    window.addEventListener("keyup", (e) => keys[e.code] = false);

    function update() {
        if (gameState !== "playing") return;

        // プレイヤー
        if (keys["ArrowLeft"]) player.dx = -player.speed;
        else if (keys["ArrowRight"]) player.dx = player.speed;
        else player.dx = 0;

        if (keys["Space"] && player.grounded) { player.dy = player.jumpPower; player.grounded = false; }
        player.dy += player.gravity;
        player.x += player.dx;
        player.y += player.dy;
        player.grounded = false;

        // 地形当たり判定
        platforms.forEach(plat => {
            if (checkCollision(player, plat)) {
                if (player.dy > 0 && player.y + player.height < plat.y + player.dy + 5) {
                    player.y = plat.y - player.height; player.dy = 0; player.grounded = true;
                } else if (player.dy < 0) {
                    player.y = plat.y + plat.h; player.dy = 0;
                }
            }
        });

        // カメラ
        if (player.x > cameraX + canvas.width / 2) cameraX = player.x - canvas.width / 2;
        cameraX = Math.max(0, Math.min(cameraX, STAGE_WIDTH - canvas.width));

        // ボス処理
        if (boss.alive) {
            boss.x += boss.dx;
            if (boss.x < boss.startX || boss.x > boss.endX) boss.dx *= -1;
            if (boss.invulnerable > 0) boss.invulnerable--;

            if (checkCollision(player, boss)) {
                if (boss.invulnerable === 0) {
                    if (player.dy > 0 && player.y + player.height < boss.y + boss.height / 2) {
                        boss.hp--; player.dy = -10; boss.invulnerable = 60;
                        statusDiv.innerText = "ボスに命中！ 残り体力: " + boss.hp;
                        if (boss.hp <= 0) {
                            boss.alive = false;
                            gameState = "cleared";
                            statusDiv.innerText = "ボス撃破！ クリア！";
                        }
                    } else {
                        gameState = "gameOver";
                        statusDiv.innerText = "ゲームオーバー (スペースでリトライ)";
                    }
                }
            }
        }
        
        if (player.y > canvas.height) { gameState = "gameOver"; statusDiv.innerText = "落下... (スペースでリトライ)"; }
        if (player.x < 0) player.x = 0;
    }

    function checkCollision(r1, r2) {
        return (r1.x < r2.x + (r2.w||r2.width) && r1.x + r1.width > r2.x && r1.y < r2.y + (r2.h||r2.height) && r1.y + r1.height > r2.y);
    }

    function resetGame() {
        player.x = 50; player.y = 200; player.dy = 0; cameraX = 0; gameState = "playing";
        boss.x = 500; boss.alive = true; boss.hp = 3; boss.invulnerable = 0;
        statusDiv.innerText = "テストモード：ボスを目の前に配置しました";
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.translate(-cameraX, 0);

        // 地形（画像がないときは緑色で描画）
        platforms.forEach(plat => {
             ctx.fillStyle = plat.color;
             ctx.fillRect(plat.x, plat.y, plat.w, plat.h);
        });

        // ボスの描画
        if (boss.alive) {
            if (boss.invulnerable > 0) ctx.globalAlpha = 0.5;
            
            if (enemyImgLoaded) {
                // 画像が読み込めていれば画像を表示
                ctx.drawImage(enemyImg, boss.x, boss.y, boss.width, boss.height);
            } else {
                // ★画像がない場合は「紫色の四角」を表示（これで絶対に見えるはず！）
                ctx.fillStyle = "purple";
                ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
                // 文字も書いておく
                ctx.fillStyle = "white";
                ctx.font = "20px Arial";
                ctx.fillText("BOSS", boss.x + 10, boss.y + 40);
            }
            ctx.globalAlpha = 1.0;
        }

        // プレイヤー（画像がなければ赤色）
        // img要素の complete プロパティで読み込み完了を簡易チェック
        if (playerImg.complete && playerImg.naturalWidth !== 0) {
            ctx.drawImage(playerImg, player.x, player.y, player.width, player.height);
        } else {
            ctx.fillStyle = player.color || "red";
            ctx.fillRect(player.x, player.y, player.width, player.height);
        }

        ctx.restore();

        if (gameState === "gameOver") {
            ctx.fillStyle = "rgba(0,0,0,0.5)"; ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle = "white"; ctx.fillText("GAME OVER", 300, 200);
        } else if (gameState === "cleared") {
            ctx.fillStyle = "rgba(255,215,0,0.5)"; ctx.fillRect(0,0,canvas.width,canvas.height);
            ctx.fillStyle = "white"; ctx.fillText("CLEAR!!", 320, 200);
        }
    }

    function loop() { update(); draw(); requestAnimationFrame(loop); }
    loop();
</script>
</body>
</html>
