<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Pintxos Tower</title>

  <!-- libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>

  <!-- shape extractor -->
  <script src="./shape-extract.js"></script>

  <style>
    body { margin:0; overflow:hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; background:#f5f5f5; touch-action:none; }
    canvas { position:fixed; inset:0; display:block; }
    #ui { position:fixed; inset:0; pointer-events:none; }
    #score { position:fixed; top:18px; left:18px; font-weight:900; font-size:40px; color:#222; text-shadow: 0 2px 0 rgba(255,255,255,.8); }
    #controls { position:fixed; left:0; right:0; bottom:22px; display:flex; gap:18px; justify-content:center; align-items:center; pointer-events:auto; }
    .btn { width:74px; height:74px; border-radius:999px; border:2px solid rgba(0,0,0,.25); background:rgba(255,255,255,.92); box-shadow:0 10px 20px rgba(0,0,0,.15); font-size:30px; display:grid; place-items:center; user-select:none; -webkit-user-select:none; }
    .btn:active { transform: translateY(2px); filter: brightness(.95); }
    #drop { width:110px; height:110px; background:#ff4d57; color:white; border:none; font-size:38px; }

    .overlay { position:fixed; inset:0; background:rgba(255,255,255,.96); display:flex; flex-direction:column; align-items:center; justify-content:center; gap:14px; z-index:50; }
    .hidden { display:none !important; }
    .title { font-size:40px; font-weight:900; letter-spacing:.02em; }
    .sub { color:#444; }
    .pill { padding:14px 44px; border-radius:999px; border:none; font-size:20px; font-weight:800; background:#2ecc71; color:white; }
    .pill:disabled { background:#bfe9cc; color:#fff; }
    .small { font-size:12px; color:#666; }

    /* debug */
    #dbgBtn { position:fixed; top:16px; right:16px; z-index:80; pointer-events:auto; background:#222; color:#fff; border:none; border-radius:999px; padding:10px 14px; font-weight:800; box-shadow:0 10px 20px rgba(0,0,0,.2); }
    #dbgPanel { position:fixed; top:64px; right:16px; width:min(420px, calc(100vw - 32px)); max-height:70vh; overflow:auto; z-index:80; background:rgba(20,20,20,.92); color:#fff; border-radius:16px; padding:14px; display:none; pointer-events:auto; box-shadow:0 20px 40px rgba(0,0,0,.25); }
    #dbgPanel pre { white-space:pre-wrap; word-break:break-word; font-size:12px; margin:0; }
    .dbgRow { border-top:1px solid rgba(255,255,255,.12); padding-top:10px; margin-top:10px; }
    .ok { color:#7CFC9A; }
    .ng { color:#FF9AA2; }
  </style>
</head>
<body>

  <div id="ui">
    <div id="score">SCORE: <span id="scoreVal">0</span></div>

    <div id="controls" class="hidden">
      <div class="btn" id="left">‚¨ÖÔ∏è</div>
      <div class="btn" id="rot">üîÑ</div>
      <div class="btn" id="right">‚û°Ô∏è</div>
      <div class="btn" id="drop">‚¨áÔ∏è</div>
    </div>
  </div>

  <button id="dbgBtn">üêû DEBUG</button>
  <div id="dbgPanel"><pre id="dbgText"></pre></div>

  <div id="title" class="overlay">
    <div class="title">Pintxos Tower</div>
    <div class="sub">Á©ç„Åø‰∏ä„Åí„Çç„ÄÇËêΩ„Å®„Åó„Åü„ÇâË≤†„Åë„ÄÇ</div>
    <button class="pill" id="startBtn" disabled>LOADING...</button>
    <div class="small" id="loadHint">„É≠„Éº„Éâ‰∏≠‚Ä¶Ôºàdebug=1 „ÅßË©≥Á¥∞Ë°®Á§∫Ôºâ</div>
  </div>

  <div id="gameover" class="overlay hidden">
    <div class="title">GAME OVER</div>
    <div class="sub">Score: <span id="finalScore">0</span></div>
    <button class="pill" id="retryBtn">RETRY</button>
  </div>

<script>
(() => {
  "use strict";

  // ====== CONFIG („Åì„Åì„Å†„ÅëËß¶„Çå„Å∞OK) ======
  const CONFIG = {
    BUILD_ID: "2026-01-01-DBG1",       // „Ç≠„É£„ÉÉ„Ç∑„É•ÊÆ∫„ÅóÁî®
    COUNT: 11,
    TEX_DIR: "./img",
    MASK_DIR: "./mask",
    USE_MASK_IF_EXISTS: true,          // mask„ÅåÁÑ°„Åë„Çå„Å∞ÈÄèÈÅéPNG(alpha)„Åã„ÇâÊäΩÂá∫
    UNREGISTER_SW_ON_DEBUG: true,      // PWA/SW„ÅåLOADING‰∫ãÊïÖËµ∑„Åì„Åô„ÅÆ„Åß„Éá„Éê„ÉÉ„Ç∞ÊôÇËß£Èô§
    DEBUG_DEFAULT: (new URLSearchParams(location.search).get("debug") === "1"),

    // Shape extraction tuning
    SHAPE: {
      sample: 160,              // downsampleÔºàÂ§ß„Åç„ÅÑ„Åª„Å©Á≤æÂ∫¶‚Üë„Å†„ÅåÈáç„ÅÑÔºâ
      alphaThreshold: 16,       // ÈÄèÈÅéÂ¢ÉÁïåÔºà‰Ωé„ÅÑ„Åª„Å©Ëº™ÈÉ≠„ÅåÂ§™„Çä„ÇÑ„Åô„ÅÑÔºâ
      dilateIters: 1,           // ËÜ®ÂºµÔºàÈöôÈñìÂØæÁ≠ñÔºâ
      minSolidRatio: 0.02,      // „Åì„ÇåÊú™Ê∫Ä„Å™„ÇâfallbackÔºàÁ¥∞„Åô„ÅéÔºâ
      simplifyEps: null,        // null„Å™„ÇâËá™Âãï
      maxVerts: 64,
      minVerts: 12,
      timeoutMs: 12000
    },

    // Sprite size (Ë¶ã„ÅüÁõÆ„ÅÆÊúÄÂ§ßËæ∫ px)
    TARGET_MAX_PX: 150,

    // physics
    MOVE_STEP: 7,
    ROT_STEP: Math.PI / 8,
    GROUND_Y_OFFSET: 180,
    GROUND_W_RATIO: 0.30,
    DEADLINE_EXTRA: 1.2, // ÁîªÈù¢‰∏ãÂà§ÂÆö„ÅÆ‰ΩôË£ï

    // debug visuals
    DRAW_COLLIDER_WIREFRAME: true
  };

  // ====== UI ======
  const $ = (id) => document.getElementById(id);
  const startBtn = $("startBtn");
  const title = $("title");
  const gameover = $("gameover");
  const scoreVal = $("scoreVal");
  const finalScore = $("finalScore");
  const retryBtn = $("retryBtn");

  const dbgBtn = $("dbgBtn");
  const dbgPanel = $("dbgPanel");
  const dbgText = $("dbgText");
  let debugOn = CONFIG.DEBUG_DEFAULT;

  function dbgPrint(lines) {
    dbgText.textContent = lines.join("\n");
  }
  function dbgShow(show) {
    dbgPanel.style.display = show ? "block" : "none";
  }
  dbgBtn.addEventListener("click", () => {
    debugOn = !debugOn;
    dbgShow(debugOn);
  });
  dbgShow(debugOn);

  // ====== Global error hooks (LOADING„ÅßÊ≠ª„Å¨ÂéüÂõ†„ÇíÁîªÈù¢„Å´Âá∫„Åô) ======
  const bootLogs = [];
  function bootLog(s) {
    bootLogs.push(s);
    if (debugOn) dbgPrint(bootLogs);
  }
  window.addEventListener("error", (e) => {
    bootLog(`[FATAL] ${e.message}`);
    if (e.error && e.error.stack) bootLog(e.error.stack);
    startBtn.disabled = false;
    startBtn.textContent = "START (ERROR)";
    $("loadHint").textContent = "„Ç®„É©„Éº„ÅßÂàùÊúüÂåñÂÅúÊ≠¢„ÄÇDEBUG„ÇíÈñã„ÅÑ„Å¶ÂéüÂõ†„ÇíË¶ã„Å¶„ÄÇ";
  });
  window.addEventListener("unhandledrejection", (e) => {
    bootLog(`[FATAL] unhandledrejection: ${(e.reason && e.reason.message) ? e.reason.message : String(e.reason)}`);
    if (e.reason && e.reason.stack) bootLog(e.reason.stack);
    startBtn.disabled = false;
    startBtn.textContent = "START (ERROR)";
    $("loadHint").textContent = "Promise„ÅåËêΩ„Å°„Åü„ÄÇDEBUG„ÇíÈñã„ÅÑ„Å¶ÂéüÂõ†„ÇíË¶ã„Å¶„ÄÇ";
  });

  // ====== Optional: unregister SW on debug (GitHub Pages„ÅßLOADING‰∫ãÊïÖÂØæÁ≠ñ) ======
  async function maybeUnregisterSW() {
    if (!CONFIG.UNREGISTER_SW_ON_DEBUG || !debugOn) return;
    if (!("serviceWorker" in navigator)) return;
    const regs = await navigator.serviceWorker.getRegistrations();
    if (regs.length) bootLog(`[SW] found ${regs.length} registrations -> unregister (debug)`);
    for (const r of regs) await r.unregister();
  }

  // ====== Matter.js setup ======
  const Engine = Matter.Engine,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Bodies = Matter.Bodies,
        Composite = Matter.Composite,
        Events = Matter.Events,
        Body = Matter.Body,
        Vertices = Matter.Vertices;

  let engine, render, runner;
  let w = innerWidth, h = innerHeight;
  let ground;
  let current = null;
  let isDropping = false;
  let gameActive = false;
  let score = 0;

  // shape cache
  const assets = []; // { texUrl, maskUrl, meta, verts, imgW, imgH, spriteScale, spriteOffset }

  // ====== Helpers ======
  function assetUrl(path) {
    // cache buster (ÈáçË¶Å: GitHub Pages + SW„ÅßÂè§„ÅÑÁîªÂÉè„ÇíÊé¥„ÇÄ„Å®Ë©∞„ÇÄ)
    return `${path}?v=${encodeURIComponent(CONFIG.BUILD_ID)}`;
  }

  function buildAssetList() {
    const list = [];
    for (let i = 1; i <= CONFIG.COUNT; i++) {
      const tex = assetUrl(`${CONFIG.TEX_DIR}/${i}.png`);
      const mask = assetUrl(`${CONFIG.MASK_DIR}/${i}.png`);
      list.push({ i, tex, mask });
    }
    return list;
  }

  function createGround() {
    if (ground) Composite.remove(engine.world, ground);
    w = innerWidth; h = innerHeight;
    const groundY = h - CONFIG.GROUND_Y_OFFSET;
    const groundW = w * CONFIG.GROUND_W_RATIO;
    ground = Bodies.rectangle(w / 2, groundY, groundW, 20, {
      isStatic: true,
      label: "Ground",
      render: { fillStyle: "#8b4513" },
      friction: 1.0
    });
    Composite.add(engine.world, ground);
  }

  function initPhysics() {
    if (!window.Matter) throw new Error("Matter.js not loaded");
    if (!window.decomp) bootLog("[WARN] poly-decomp not loaded (concave may fail)");
    // Matter needs decomp to decompose concave polygons
    if (window.decomp && Matter && Matter.Common && Matter.Common.setDecomp) {
      Matter.Common.setDecomp(window.decomp);
    } else {
      // fallback: Matter.js also checks window.decomp
      window.decomp = window.decomp || window.decomp;
    }

    engine = Engine.create();
    render = Render.create({
      element: document.body,
      engine,
      options: {
        width: w,
        height: h,
        background: "#f5f5f5",
        wireframes: false,
        showAngleIndicator: false,
        pixelRatio: devicePixelRatio || 1
      }
    });
    Render.run(render);
    runner = Runner.create();
    Runner.run(runner, engine);

    createGround();
    Render.lookAt(render, { min: { x: 0, y: 0 }, max: { x: w, y: h } });

    Events.on(engine, "beforeUpdate", updateLoop);

    addEventListener("resize", () => {
      w = innerWidth; h = innerHeight;
      render.canvas.width = w;
      render.canvas.height = h;
      createGround();
      Render.lookAt(render, { min: { x: 0, y: render.bounds.min.y }, max: { x: w, y: render.bounds.min.y + h } });
    });
  }

  function updateLoop() {
    if (!gameActive) return;

    // gameover: dropped bodies go below screen
    const bodies = Composite.allBodies(engine.world);
    const deadLine = (render.bounds.min.y + h) * CONFIG.DEADLINE_EXTRA;

    for (const b of bodies) {
      if (b.label === "Pintxo" && b !== current) {
        if (b.position.y > deadLine) {
          gameOver();
          return;
        }
      }
    }

    // camera follow top
    let highestY = ground.position.y;
    let hasStack = false;
    for (const b of bodies) {
      if (b.label === "Pintxo" && b !== current) {
        if (b.position.y < highestY) { highestY = b.position.y; hasStack = true; }
      }
    }

    let targetTopY = 0;
    if (hasStack) targetTopY = highestY - (h * 0.55);
    if (targetTopY > 0) targetTopY = 0;

    const curTop = render.bounds.min.y;
    const nextTop = curTop + (targetTopY - curTop) * 0.06;
    Render.lookAt(render, { min: { x: 0, y: nextTop }, max: { x: w, y: nextTop + h } });
  }

  function calcScore(body) {
    const diff = ground.position.y - body.position.y;
    if (diff > 0) score += Math.floor(diff / 10) + 10;
    scoreVal.textContent = String(score);
  }

  // ====== Spawn ======
  function pickAsset() {
    return assets[Math.floor(Math.random() * assets.length)];
  }

  function spawn() {
    if (!gameActive) return;
    if (!assets.length) {
      bootLog("[FATAL] no assets loaded");
      gameOver();
      return;
    }

    const a = pickAsset();
    const spawnX = w / 2;
    const spawnY = render.bounds.min.y + 120;

    const spriteScale = a.spriteScale;
    const xOffset = a.spriteOffset?.x ?? 0.5;
    const yOffset = a.spriteOffset?.y ?? 0.5;

    const commonOpts = {
      label: "Pintxo",
      restitution: 0.05,
      friction: 0.9,
      frictionAir: 0.02,
      render: {
        sprite: {
          texture: a.texUrl,
          xScale: spriteScale,
          yScale: spriteScale,
          xOffset,
          yOffset
        }
      }
    };

    let body = null;

    if (a.verts && a.verts.length >= 8) {
      // scale verts to match sprite scale (verts are centered at centroid in image px)
      const scaled = a.verts.map(v => ({ x: v.x * spriteScale, y: v.y * spriteScale }));

      body = Bodies.fromVertices(spawnX, spawnY, [scaled], commonOpts, true);

      if (!body) {
        bootLog(`[WARN] fromVertices returned null -> RECT fallback for ${a.texUrl}`);
      }
    }

    if (!body) {
      // RECT fallback (should be rare; debug will tell why)
      const rw = (a.imgW || 80) * spriteScale * 0.9;
      const rh = (a.imgH || 60) * spriteScale * 0.9;
      body = Bodies.rectangle(spawnX, spawnY, rw, rh, commonOpts);
      body.__forcedRect = true;
    }

    // debug draw collider outline (optional)
    if (debugOn && CONFIG.DRAW_COLLIDER_WIREFRAME) {
      body.render.strokeStyle = "rgba(0,255,0,0.9)";
      body.render.lineWidth = 2;
    }

    Body.setStatic(body, true);
    current = body;
    isDropping = false;
    Composite.add(engine.world, body);

    // show last meta in debug
    if (debugOn) {
      bootLog("---- SPAWN ----");
      bootLog(`tex: ${a.texUrl}`);
      bootLog(`mask: ${a.maskUrl || "-"}`);
      bootLog(`fallback: ${a.meta?.fallback ? "true" : "false"} reason: ${a.meta?.reason || "-"}`);
      bootLog(`verts: ${a.meta?.vertsCount ?? 0} solidRatio: ${a.meta?.solidRatio?.toFixed?.(3) ?? "-"}`);
      bootLog(`spriteScale: ${spriteScale.toFixed(3)} offset: (${xOffset.toFixed(3)}, ${yOffset.toFixed(3)})`);
      if (current.__forcedRect) bootLog("[RECT] forced rect collider");
      dbgPrint(bootLogs);
    }
  }

  function move(dir) {
    if (current && !isDropping) Body.translate(current, { x: dir * CONFIG.MOVE_STEP, y: 0 });
  }
  function rotate() {
    if (current && !isDropping) Body.rotate(current, CONFIG.ROT_STEP);
  }
  function drop() {
    if (!current || isDropping) return;
    isDropping = true;
    Body.setStatic(current, false);
    const dropped = current;

    // settle wait („Çø„Ç§„É†„Ç¢„Ç¶„Éà„ÇÇ‰ªò„Åë„Çã„ÅÆ„ÅßÊ≠¢„Åæ„Çâ„Å™„ÅÑ)
    const t0 = performance.now();
    const check = () => {
      if (!gameActive) return;
      const v = dropped.velocity;
      const speed = Math.hypot(v.x, v.y);
      const ang = Math.abs(dropped.angularVelocity);

      if ((speed < 0.15 && ang < 0.15) || (performance.now() - t0 > 2200)) {
        calcScore(dropped);
        spawn();
      } else {
        requestAnimationFrame(check);
      }
    };
    requestAnimationFrame(check);
  }

  // ====== Controls ======
  const hold = (el, fn) => {
    let t = null;
    const start = (e) => { e.preventDefault(); fn(); t = setInterval(fn, 50); };
    const end = (e) => { e.preventDefault(); if (t) clearInterval(t); t = null; };
    el.addEventListener("touchstart", start, { passive:false });
    el.addEventListener("touchend", end);
    el.addEventListener("touchcancel", end);
    el.addEventListener("mousedown", start);
    el.addEventListener("mouseup", end);
    el.addEventListener("mouseleave", end);
  };

  function bindControls() {
    const left = $("left"), right = $("right"), rot = $("rot"), dropBtn = $("drop");
    hold(left, () => move(-1));
    hold(right, () => move(1));
    rot.addEventListener("click", rotate);
    rot.addEventListener("touchstart", (e) => { e.preventDefault(); rotate(); }, { passive:false });
    dropBtn.addEventListener("click", drop);
    dropBtn.addEventListener("touchstart", (e) => { e.preventDefault(); drop(); }, { passive:false });
  }

  // ====== Game flow ======
  function startGame() {
    title.classList.add("hidden");
    gameover.classList.add("hidden");
    $("controls").classList.remove("hidden");

    Composite.clear(engine.world, false);
    Engine.clear(engine);

    score = 0;
    scoreVal.textContent = "0";
    gameActive = true;

    createGround();
    Render.lookAt(render, { min: { x: 0, y: 0 }, max: { x: w, y: h } });

    spawn();
  }

  function gameOver() {
    gameActive = false;
    $("controls").classList.add("hidden");
    finalScore.textContent = String(score);
    gameover.classList.remove("hidden");
  }

  retryBtn.addEventListener("click", startGame);

  // ====== LOADER („Åì„Åì„Åå‰ªäÂõû„ÅÆÊú¨‰∏∏ÔºöÁµ∂ÂØæ„Å´Âõ∫„Åæ„Çâ„Å™„ÅÑ) ======
  async function preloadAssets() {
    bootLog(`[BOOT] debugOn=${debugOn}`);
    await maybeUnregisterSW();

    // sanity checks
    bootLog(`[LIB] Matter=${!!window.Matter} decomp=${!!window.decomp} ShapeExtract=${!!window.ShapeExtract}`);

    const list = buildAssetList();
    const logger = [];

    let okCount = 0, failCount = 0;

    for (const item of list) {
      const texUrl = item.tex;
      const maskUrl = CONFIG.USE_MASK_IF_EXISTS ? item.mask : null;

      // load texture first (ÂøÖÈ†à)
      let texImg;
      try {
        texImg = await ShapeExtract.loadImage(texUrl, 8000);
      } catch (e) {
        failCount++;
        bootLog(`[ASSET NG] tex missing: ${texUrl} (${e.message})`);
        continue;
      }

      // extract from mask if exists, else from texture alpha
      const res = await ShapeExtract.extract({
        srcUrl: texUrl,
        maskUrl: maskUrl,
        sample: CONFIG.SHAPE.sample,
        alphaThreshold: CONFIG.SHAPE.alphaThreshold,
        dilateIters: CONFIG.SHAPE.dilateIters,
        minSolidRatio: CONFIG.SHAPE.minSolidRatio,
        simplifyEps: CONFIG.SHAPE.simplifyEps,
        maxVerts: CONFIG.SHAPE.maxVerts,
        minVerts: CONFIG.SHAPE.minVerts,
        timeoutMs: CONFIG.SHAPE.timeoutMs,
        logger
      });

      // sprite scale: fit max dimension to TARGET_MAX_PX
      const iw = texImg.naturalWidth || texImg.width;
      const ih = texImg.naturalHeight || texImg.height;
      const spriteScale = CONFIG.TARGET_MAX_PX / Math.max(iw, ih);

      assets.push({
        texUrl,
        maskUrl,
        meta: res.meta,
        verts: res.verts,
        imgW: iw,
        imgH: ih,
        spriteScale,
        spriteOffset: res.meta?.spriteOffset || { x: 0.5, y: 0.5 }
      });

      okCount++;
      bootLog(`[ASSET OK] #${item.i} fallback=${res.meta.fallback ? "true" : "false"} verts=${res.meta.vertsCount} solid=${res.meta.solidRatio.toFixed(3)} used=${res.meta.used}`);
      dbgPrint(bootLogs);
    }

    // show summary
    bootLog(`[DONE] assets=${assets.length}/${CONFIG.COUNT} fail=${failCount}`);
    dbgPrint(bootLogs);

    if (assets.length === 0) {
      $("loadHint").textContent = "ÁîªÂÉè„Åå1Êûö„ÇÇË™≠„ÇÅ„Å¶„Å™„ÅÑ„ÄÇimg/ „Å®„Éï„Ç°„Ç§„É´Âêç„ÇíÁ¢∫Ë™ç„ÄÇ";
      startBtn.disabled = false;
      startBtn.textContent = "START (NO ASSET)";
      return;
    }

    startBtn.disabled = false;
    startBtn.textContent = "START";
    $("loadHint").textContent = debugOn ? "DEBUG„Å´„É≠„Éº„ÉâÁµêÊûú„ÅåÂá∫„Å¶„ÅÑ„Åæ„Åô" : "Ê∫ñÂÇôÂÆå‰∫Ü";
  }

  // ====== Boot ======
  startBtn.addEventListener("click", startGame);

  bindControls();
  initPhysics();
  preloadAssets();

})();
</script>
</body>
</html>
