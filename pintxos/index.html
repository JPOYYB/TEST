<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Pintxos Tower</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <script src="./shape-extract.js"></script>

  <style>
    body { margin:0; overflow:hidden; background:#f2f2f2; font-family:system-ui, -apple-system, sans-serif; touch-action:none; }
    canvas { display:block; position:fixed; inset:0; z-index:0; }

    #ui { position:fixed; inset:0; z-index:10; pointer-events:none; }
    #score { position:absolute; top:16px; left:16px; font-weight:900; font-size:34px; color:#222; text-shadow:2px 2px 0 rgba(255,255,255,0.85); }

    #controls { position:absolute; bottom:24px; left:0; width:100%; display:flex; justify-content:center; gap:16px; pointer-events:auto; }
    .btn { width:72px; height:72px; border-radius:999px; border:2px solid rgba(0,0,0,0.35); background:rgba(255,255,255,0.95);
           box-shadow:0 6px 10px rgba(0,0,0,0.18); font-size:28px; }
    .btn:active { transform:translateY(2px); background:#ddd; }
    #drop { width:92px; height:92px; background:#ff4a5d; color:#fff; border:none; font-size:34px; }

    .overlay { position:fixed; inset:0; z-index:20; background:rgba(255,255,255,0.96); display:flex; flex-direction:column; justify-content:center; align-items:center; gap:12px; }
    .hidden { display:none !important; }
    .primary { padding:14px 34px; font-size:18px; border-radius:999px; border:none; background:#2ecc71; color:#fff; }
    .hint { opacity:0.75; }

    #dbgToggle { position:fixed; top:14px; right:14px; z-index:30; pointer-events:auto;
      padding:10px 14px; border-radius:999px; border:0; background:#222; color:#fff; opacity:0.88; }
    #dbgPanel { position:fixed; top:60px; right:14px; z-index:30; pointer-events:none;
      width:320px; max-width:88vw; background:rgba(20,20,20,0.86); color:#fff; border-radius:16px;
      padding:12px 14px; font-size:12px; line-height:1.35; white-space:pre-wrap; }
  </style>
</head>
<body>

  <div id="ui">
    <div id="score">SCORE: <span id="sv">0</span></div>
    <div id="controls" class="hidden">
      <button class="btn" id="left">‚¨ÖÔ∏è</button>
      <button class="btn" id="rot">üîÑ</button>
      <button class="btn" id="right">‚û°Ô∏è</button>
      <button class="btn" id="drop">‚¨áÔ∏è</button>
    </div>
  </div>

  <button id="dbgToggle" class="hidden">üêû DEBUG</button>
  <div id="dbgPanel" class="hidden"></div>

  <div id="loading" class="overlay">
    <h1 style="margin:0;">Pintxos Tower</h1>
    <div class="hint">Á©ç„Åø‰∏ä„Åí„Çç„ÄÇËêΩ„Å®„Åó„Åü„ÇâË≤†„Åë„ÄÇ</div>
    <button class="primary" disabled>LOADING...</button>
  </div>

  <div id="title" class="overlay hidden">
    <h1 style="margin:0;">Pintxos Tower</h1>
    <div class="hint">Á©ç„Åø‰∏ä„Åí„Çç„ÄÇËêΩ„Å®„Åó„Åü„ÇâË≤†„Åë„ÄÇ</div>
    <button class="primary" id="start">START</button>
  </div>

  <div id="over" class="overlay hidden">
    <h1 style="margin:0;">GAME OVER</h1>
    <div>Score: <span id="final">0</span></div>
    <div id="inputArea">
      <input id="name" maxlength="8" placeholder="ÂêçÂâç" style="padding:10px; font-size:16px; text-align:center;">
      <div style="height:8px"></div>
      <button class="primary" id="save">„É©„É≥„Ç≠„É≥„Ç∞ÁôªÈå≤</button>
      <div style="height:8px"></div>
      <button id="retry" style="background:none;border:none;text-decoration:underline;opacity:.75;">„É™„Éà„É©„Ç§</button>
    </div>
    <div id="rankArea" class="hidden">
      <h3 style="margin:8px 0;">„É©„É≥„Ç≠„É≥„Ç∞</h3>
      <ul id="rank" style="list-style:none; padding:0; margin:0; width:240px;"></ul>
      <div style="height:8px"></div>
      <button class="primary" id="again">„ÇÇ„ÅÜ‰∏ÄÂ∫¶</button>
    </div>
  </div>

<script>
/* =========================
   PATCH: „Åì„Åì„Å†„ÅëËß¶„Çå„Å∞Ë™øÊï¥„Åß„Åç„Çã
   ========================= */
const CONFIG = {
  COUNT: 11,
  TEX_DIR: "img",
  MASK_DIR: "mask",

  SPRITE_BASE: 100,       // ÁîªÂÉè„ÅÆÂü∫Ê∫ñ„Çµ„Ç§„Ç∫Ôºà100x100ÊÉ≥ÂÆöÔºâ
  SPRITE_SCALE: 1.00,     // Ë°®Á§∫ÂÄçÁéáÔºà„Åæ„Åö„ÅØ1.00Âõ∫ÂÆö„ÅßÂÆâÂÆö„Åï„Åõ„ÇãÔºâ
  HIT_SCALE: 0.98,        // ÂΩì„Åü„ÇäÂà§ÂÆöÔºà„Éù„É™„Ç¥„É≥ÔºâÂÄçÁéáÔºöÈöôÈñì„ÇíË©∞„ÇÅ„Åü„ÅÑ„Å™„Çâ 0.96-1.00 „ÅßË™øÊï¥

  MOVE_PX: 7,             // Â∑¶Âè≥ÁßªÂãï
  ROT_RAD: Math.PI/8,     // ÂõûËª¢

  GROUND_Y_FROM_BOTTOM: 190,
  GROUND_W_RATIO: 0.72,

  SETTLE_FRAMES: 18,
  SPEED_EPS: 0.25,
  ANG_EPS: 0.025,

  FORCE_FREEZE_MS: 20000,     // 20Áßí‰ª•ÂÜÖ„Å´Ê≠¢„ÇÅ„Çã
  FREEZE_OTHERS_MS: 20000,    // Âè§„ÅÑ„ÅÆ„ÇÇÊ≠¢„ÇÅ„Çã

  MAX_STACK: 30,              // Â§ö„Åô„Åé„Çã„Å®Èáç„Åè„Å™„Çã„ÅÆ„Åß‰∏äÈôê

  MASK: { alphaThreshold: 8, dilate: 1, simplifyEps: 1.2, maxPoints: 64, minArea: 40 },

  // „Éá„Éê„ÉÉ„Ç∞
  OUTLINE: true,
};
/* ========================= */

const Engine = Matter.Engine;
const Render = Matter.Render;
const Runner = Matter.Runner;
const Bodies = Matter.Bodies;
const Composite = Matter.Composite;
const Events = Matter.Events;
const Body = Matter.Body;
const Sleeping = Matter.Sleeping;

let engine, render, runner;
let w = innerWidth, h = innerHeight;

let ground = null;
let score = 0;
let gameActive = false;

let current = null;
let dropping = false;
let settleCount = 0;
let dropStartMs = 0;

let assets = [];     // {id, tex, mask}
let shapes = {};     // id -> {verts,...}
let debugOn = false;
let spawnTimer = 0;
let spawnSeq = 0;

const $ = (id)=>document.getElementById(id);
const log = (...a)=>console.log(...a);
const dbgPanel = $("dbgPanel");

function setDbg(text){
  if(!debugOn) return;
  dbgPanel.textContent = text;
}

function show(el, on){ el.classList.toggle("hidden", !on); }

function buildAssets(){
  assets = [];
  for(let i=1;i<=CONFIG.COUNT;i++){
    assets.push({
      id: i,
      tex: `${CONFIG.TEX_DIR}/${i}.png`,
      mask: `${CONFIG.MASK_DIR}/${i}.png`,
    });
  }
}

function preloadImages(urls){
  return Promise.all(urls.map(url => new Promise((resolve,reject)=>{
    const img = new Image();
    img.onload = ()=>resolve(img);
    img.onerror = ()=>reject(new Error("Texture load failed: "+url));
    img.src = url;
    setTimeout(()=>reject(new Error("Texture timeout: "+url)), 8000);
  })));
}

/* =========================
   PATCH: Â§ßÈáè„Çπ„Éù„Éº„É≥Èò≤Ê≠¢„ÅÆ‰∏≠Ê†∏
   ========================= */
function requestSpawn(delayMs=250){
  if(!gameActive) return;
  if(current) return;
  if(spawnTimer) return;
  spawnTimer = setTimeout(()=>{
    spawnTimer = 0;
    if(!gameActive) return;
    if(current) return;
    spawnOne();
  }, delayMs);
}
/* ========================= */

function createWorld(){
  engine = Engine.create();
  // Áâ©ÁêÜ„ÅÆÂÆâÂÆöÊÄß„ÇíÂ∞ë„Åó‰∏ä„Åí„Çã
  engine.positionIterations = 10;
  engine.velocityIterations = 10;

  // concaveÂØæÂøú
  if (window.decomp) Matter.Common.setDecomp(window.decomp);

  render = Render.create({
    element: document.body,
    engine,
    options: {
      width: w,
      height: h,
      wireframes: false,
      background: "#f2f2f2",
      pixelRatio: devicePixelRatio || 1
    }
  });
  render.options.showSleeping = false; // ‚ÜêËñÑ„Åè„Å™„Çâ„Å™„ÅÑ

  Render.run(render);
  runner = Runner.create();
  Runner.run(runner, engine);

  Events.on(engine, "beforeUpdate", tick);
  Events.on(render, "afterRender", drawDebug);

  addEventListener("resize", ()=>{
    w = innerWidth; h = innerHeight;
    render.canvas.width = w; render.canvas.height = h;
    createGround();
  });
}

function createGround(){
  if(ground) Composite.remove(engine.world, ground);

  const y = h - CONFIG.GROUND_Y_FROM_BOTTOM;
  const gw = w * CONFIG.GROUND_W_RATIO;

  ground = Bodies.rectangle(w/2, y, gw, 20, {
    isStatic: true,
    label: "Ground",
    friction: 1.0,
    render: { fillStyle: "#8b4513" }
  });
  Composite.add(engine.world, ground);
}

function resetWorld(){
  Composite.clear(engine.world);
  Engine.clear(engine);
  createGround();
  Render.lookAt(render, {min:{x:0,y:0}, max:{x:w,y:h}});
}

function startGame(){
  show($("title"), false);
  show($("over"), false);
  show($("controls"), true);

  resetWorld();

  score = 0;
  $("sv").textContent = score;

  current = null;
  dropping = false;
  settleCount = 0;

  gameActive = true;
  requestSpawn(0);
}

function spawnOne(){
  if(!gameActive) return;
  if(current) return;

  const a = assets[Math.floor(Math.random()*assets.length)];
  const s = shapes[a.id];
  if(!s || !s.verts){
    // „Åì„Åì„Å´Êù•„Çã„Å™„Çâ shape „ÅåÂ£ä„Çå„Å¶„Çã
    setDbg(`spawn fail: shape missing id=${a.id}`);
    requestSpawn(300);
    return;
  }

  const spawnX = w/2;
  const spawnY = (render.bounds.min.y || 0) + 120;

  const scaleSprite = CONFIG.SPRITE_SCALE;       // Ë°®Á§∫ÂÄçÁéá
  const scaleHit = CONFIG.SPRITE_SCALE * CONFIG.HIT_SCALE;

  // Bodies.fromVertices „ÅØ ‚Äú‰∏≠Â§ÆÂ∫ßÊ®ô + verts(„É≠„Éº„Ç´„É´)‚Äù „ÅÆ„Å§„ÇÇ„Çä„Åß‰Ωø„ÅÜ
  let body = Bodies.fromVertices(spawnX, spawnY, [s.verts], {
    label: "Pintxo",
    friction: 0.9,
    frictionStatic: 1.2,
    restitution: 0.03,
    density: 0.002,
    frictionAir: 0.03,
    render: {
      sprite: {
        texture: a.tex,
        xScale: scaleSprite,
        yScale: scaleSprite,
        xOffset: 0.5,
        yOffset: 0.5
      }
    }
  }, true);

  if(!body){
    // ÊúÄÁµÇfallbackÔºàÁµ∂ÂØæ„Å´Ê∂à„Åï„Å™„ÅÑÔºâ
    body = Bodies.rectangle(spawnX, spawnY, 70*scaleHit, 50*scaleHit, {
      label: "Pintxo",
      friction: 0.9, frictionStatic: 1.2, restitution: 0.03, density: 0.002, frictionAir: 0.03,
      render: { sprite:{ texture:a.tex, xScale:scaleSprite, yScale:scaleSprite, xOffset:0.5, yOffset:0.5 } }
    });
  } else {
    Body.scale(body, scaleHit, scaleHit);
  }

  // aim‰∏≠„ÅØÈùôÊ≠¢
  Body.setStatic(body, true);

  body.__id = ++spawnSeq;
  body.__bornMs = performance.now();
  body.__assetId = a.id;
  body.__fallback = !!s.fallback;
  body.__isCurrent = true;

  current = body;
  dropping = false;
  settleCount = 0;

  Composite.add(engine.world, body);

  if(debugOn){
    setDbg(
      `[SPAWN #${body.__id}] asset=${a.id}\n`+
      `fallback=${s.fallback} reason=${s.reason}\n`+
      `verts=${s.verts.length} solid=${(s.meta?.solidRatio??0).toFixed(3)}\n`+
      `HIT_SCALE=${CONFIG.HIT_SCALE} SPRITE_SCALE=${CONFIG.SPRITE_SCALE}`
    );
  }
}

function drop(){
  if(!current || dropping) return;
  dropping = true;
  dropStartMs = performance.now();
  Body.setStatic(current, false);
}

function move(dx){
  if(!current || dropping) return;
  const nx = Math.max(40, Math.min(w-40, current.position.x + dx));
  Body.setPosition(current, {x:nx, y: current.position.y});
}

function rotate(){
  if(!current || dropping) return;
  Body.rotate(current, CONFIG.ROT_RAD);
}

function cleanupStack(){
  const list = Composite.allBodies(engine.world).filter(b => b.label==="Pintxo" && !b.__isCurrent);
  if(list.length <= CONFIG.MAX_STACK) return;
  list.sort((a,b)=>(a.__id||0)-(b.__id||0));
  const rm = list.length - CONFIG.MAX_STACK;
  for(let i=0;i<rm;i++){
    Composite.remove(engine.world, list[i]);
  }
}

function freezeBody(b){
  Body.setVelocity(b, {x:0,y:0});
  Body.setAngularVelocity(b, 0);
  Sleeping.set(b, true);
  Body.setStatic(b, true);
}

function addScoreFor(b){
  const diff = ground.position.y - b.position.y;
  if(diff > 0){
    score += (Math.floor(diff/10) + 10);
    $("sv").textContent = score;
  }
}

function gameOver(){
  gameActive = false;
  show($("controls"), false);
  $("final").textContent = score;
  show($("over"), true);
  show($("rankArea"), false);
  show($("inputArea"), true);
}

function tick(){
  if(!gameActive) return;

  // „É´„Éº„Ç∫Êù°‰ª∂ÔºöÂú∞Èù¢„Çà„ÇäÂçÅÂàÜ‰∏ã„Å´ËêΩ„Å°„Åü„ÇâË≤†„Åë
  const loseY = ground.position.y + h*1.1;
  const bodies = Composite.allBodies(engine.world);

  for(const b of bodies){
    if(b.label !== "Pintxo") continue;
    if(b.__isCurrent) continue;
    if(b.position.y > loseY){
      gameOver();
      return;
    }
  }

  // dropping‰∏≠„ÅÆÁ¢∫ÂÆöÂà§ÂÆö
  if(current && dropping){
    const v = current.velocity;
    const speed = Math.hypot(v.x, v.y);
    const ang = Math.abs(current.angularVelocity);

    // 20Áßí‰ª•ÂÜÖ„Å´Ê≠¢„ÇÅ„ÇãÔºà„Éñ„É´„Éñ„É´ÂØæÁ≠ñ„ÅÆÊúÄÁµÇÂÖµÂô®Ôºâ
    const age = performance.now() - dropStartMs;
    if(age > CONFIG.FORCE_FREEZE_MS){
      freezeBody(current);
      current.__isCurrent = false;
      addScoreFor(current);
      cleanupStack();
      current = null;
      dropping = false;
      settleCount = 0;
      requestSpawn(0);
      return;
    }

    if(speed < CONFIG.SPEED_EPS && ang < CONFIG.ANG_EPS){
      settleCount++;
    } else {
      settleCount = 0;
    }

    if(settleCount >= CONFIG.SETTLE_FRAMES){
      // Á¢∫ÂÆö
      freezeBody(current);
      current.__isCurrent = false;
      addScoreFor(current);
      cleanupStack();
      current = null;
      dropping = false;
      settleCount = 0;
      requestSpawn(220);
      return;
    }
  }

  // Âè§„ÅÑ„Éî„É≥„ÉÅ„Éß„Çπ„ÇÇ20Áßí„ÅßÊ≠¢„ÇÅ„Çã
  const now = performance.now();
  for(const b of bodies){
    if(b.label !== "Pintxo") continue;
    if(b.__isCurrent) continue;
    const age = now - (b.__bornMs || now);
    if(age > CONFIG.FREEZE_OTHERS_MS){
      const v = b.velocity;
      const speed = Math.hypot(v.x, v.y);
      const ang = Math.abs(b.angularVelocity);
      if(speed > CONFIG.SPEED_EPS || ang > CONFIG.ANG_EPS){
        freezeBody(b);
      }
    }
  }

  // „Ç´„É°„É©ËøΩÂæìÔºà‰∏äÊñπÂêëÔºâ
  let highestY = ground.position.y;
  let has = false;
  for(const b of bodies){
    if(b.label !== "Pintxo") continue;
    if(b.__isCurrent) continue;
    if(b.position.y < highestY){
      highestY = b.position.y;
      has = true;
    }
  }
  let targetTop = 0;
  if(has) targetTop = highestY - h*0.55;
  if(targetTop > 0) targetTop = 0;

  const curTop = render.bounds.min.y;
  if(targetTop < curTop){
    const ny = curTop + (targetTop-curTop)*0.06;
    Render.lookAt(render, {min:{x:0,y:ny}, max:{x:w,y:ny+h}});
  } else if(curTop < 0 && !has){
    Render.lookAt(render, {min:{x:0,y:0}, max:{x:w,y:h}});
  }
}

function drawDebug(){
  if(!debugOn || !CONFIG.OUTLINE) return;
  const ctx = render.context;
  const bodies = Composite.allBodies(engine.world);

  Matter.Render.startViewTransform(render);

  for(const b of bodies){
    if(b.label !== "Pintxo") continue;
    const vs = b.vertices;
    ctx.beginPath();
    ctx.moveTo(vs[0].x, vs[0].y);
    for(let i=1;i<vs.length;i++) ctx.lineTo(vs[i].x, vs[i].y);
    ctx.closePath();
    ctx.lineWidth = 2;
    ctx.strokeStyle = b.__isCurrent ? "#00ff66" : "rgba(0,180,255,0.55)";
    ctx.stroke();
  }

  Matter.Render.endViewTransform(render);
}

/* Ranking */
function saveScore(){
  const name = ($("name").value || "ÂêçÁÑ°„Åó").slice(0,8);
  const data = JSON.parse(localStorage.getItem("pintxosRank") || "[]");
  data.push({name, score});
  data.sort((a,b)=>b.score-a.score);
  localStorage.setItem("pintxosRank", JSON.stringify(data.slice(0,5)));
  showRank();
}
function showRank(){
  const data = JSON.parse(localStorage.getItem("pintxosRank") || "[]");
  const ul = $("rank");
  ul.innerHTML = "";
  data.forEach((d,i)=>{
    const li = document.createElement("li");
    li.style.display="flex";
    li.style.justifyContent="space-between";
    li.style.borderBottom="1px solid rgba(255,255,255,0.25)";
    li.style.padding="6px 0";
    li.innerHTML = `<span>${i+1}. ${d.name}</span><span>${d.score}</span>`;
    ul.appendChild(li);
  });
  show($("inputArea"), false);
  show($("rankArea"), true);
}

function initControls(){
  const hold = (el, fn)=>{
    let t=0;
    const start=(e)=>{e.preventDefault(); fn(); t=setInterval(fn, 50);};
    const end=(e)=>{e.preventDefault(); clearInterval(t); t=0;};
    el.addEventListener("touchstart", start, {passive:false});
    el.addEventListener("touchend", end);
    el.addEventListener("mousedown", start);
    el.addEventListener("mouseup", end);
    el.addEventListener("mouseleave", end);
  };
  hold($("left"), ()=>move(-CONFIG.MOVE_PX));
  hold($("right"), ()=>move(CONFIG.MOVE_PX));
  $("rot").addEventListener("click", rotate);
  $("rot").addEventListener("touchstart", (e)=>{e.preventDefault(); rotate();},{passive:false});
  $("drop").addEventListener("click", drop);
  $("drop").addEventListener("touchstart", (e)=>{e.preventDefault(); drop();},{passive:false});

  $("start").onclick = startGame;
  $("retry").onclick = ()=>{ show($("over"), false); startGame(); };
  $("again").onclick = ()=>{ show($("over"), false); startGame(); };
  $("save").onclick = saveScore;
}

async function boot(){
  // debug switch
  const qs = new URLSearchParams(location.search);
  debugOn = qs.has("debug") || localStorage.getItem("debugOn")==="1";

  show($("dbgToggle"), debugOn);
  show($("dbgPanel"), debugOn);
  $("dbgToggle").onclick = ()=>{
    debugOn = !debugOn;
    localStorage.setItem("debugOn", debugOn ? "1" : "0");
    location.reload();
  };

  buildAssets();
  createWorld();
  createGround();
  initControls();

  log(`[BOOT] debugOn=${debugOn}`);
  log(`[LIB] Matter=${!!Matter} decomp=${!!window.decomp} ShapeExtract=${!!window.ShapeExtract}`);

  // ÂÖà„Å´ texture „ÇÇ mask „ÇÇ„É≠„Éº„Éâ„Åó„Å¶„ÄÅLOADINGÊ≠¢„Åæ„Çä„ÇíÊΩ∞„Åô
  try {
    await preloadImages(assets.map(a=>a.tex));
  } catch(e){
    console.error(e);
    $("loading").querySelector("button").textContent = "TEXTURE LOAD FAILED";
    return;
  }

  const pack = await ShapeExtract.loadAll(assets, CONFIG.MASK);
  shapes = pack.shapes;

  // „É≠„Ç∞Ôºà„ÅÇ„Å™„Åü„ÅÆË≤º„Å£„Å¶„Åè„Çå„Åü„ÇÑ„Å§„Å®ÂêåÂΩ¢ÂºèÔºâ
  for(const r of pack.results){
    const used = r.fallback ? "rect" : "mask";
    const v = r.verts ? r.verts.length : 0;
    const solid = (r.meta?.solidRatio ?? 0).toFixed(3);
    const bb = r.meta?.bbox;
    const crop = bb ? `${(bb.maxX-bb.minX+1)}x${(bb.maxY-bb.minY+1)}` : "-";
    log(`[ASSET OK] #${r.id} used=${used} solid=${solid} verts=${v} crop=${crop}`);
  }
  log(`[DONE] assets=${pack.results.length}/${assets.length} fail=0`);

  show($("loading"), false);
  show($("title"), true);
}

boot();
</script>
</body>
</html>
