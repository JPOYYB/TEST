<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Pintxos Tower</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <script src="./shape-extract.js?v=10"></script>

  <style>
    body { margin:0; padding:0; overflow:hidden; background:#f0f0f0; font-family: system-ui, -apple-system, Segoe UI, sans-serif; touch-action:none; }
    #game-root { position:fixed; inset:0; z-index:0; }
    canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }
    #ui-layer { position:fixed; inset:0; z-index:10; pointer-events:none; }
    #score-board { position:absolute; top:18px; left:18px; font-size:28px; font-weight:800; color:#222; text-shadow:2px 2px 0 #fff; }
    #controls { position:absolute; bottom:22px; left:0; width:100%; height:92px; display:flex; justify-content:center; align-items:center; gap:18px; pointer-events:auto; }
    .control-btn { width:64px; height:64px; background:rgba(255,255,255,.95); border:2px solid #888; border-radius:50%; font-size:26px; display:flex; align-items:center; justify-content:center; box-shadow:0 4px 10px rgba(0,0,0,.18); user-select:none; -webkit-user-select:none; }
    .control-btn:active { transform:translateY(2px); background:#e6e6e6; }
    #btn-drop { width:88px; height:88px; background:#ff4757; color:#fff; border:none; font-size:34px; }

    .overlay { position:fixed; inset:0; background:rgba(255,255,255,.96); display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:20; pointer-events:auto; }
    .hidden { display:none !important; }
    .primary-btn { padding:14px 36px; font-size:18px; background:#2ecc71; color:#fff; border:none; border-radius:999px; cursor:pointer; margin-top:14px; }

    #debug-btn { position:fixed; top:14px; right:14px; z-index:30; pointer-events:auto; background:#111; color:#fff; border:none; padding:10px 14px; border-radius:999px; box-shadow:0 6px 18px rgba(0,0,0,.25); font-weight:700; }
    #debug-panel { position:fixed; right:14px; top:64px; width:min(360px, calc(100vw - 28px)); z-index:30; pointer-events:auto; background:rgba(20,20,20,.88); color:#fff; border-radius:16px; padding:14px; font-size:13px; line-height:1.35; white-space:pre-wrap; }
    #debug-panel.hidden { display:none !important; }
    #debug-panel code { color:#b8ffb8; }

    #loading { text-align:center; }
    #loading h1 { margin:0 0 6px 0; font-size:40px; }
    #loading p { margin:0 0 18px 0; color:#333; }
    #loading .pill { padding:14px 28px; border-radius:999px; background:#2ecc71; color:#fff; font-weight:800; }
  </style>
</head>

<body>
  <div id="game-root"></div>

  <div id="ui-layer">
    <div id="score-board">SCORE: <span id="score-val">0</span></div>
    <div id="controls" class="hidden">
      <button class="control-btn" id="btn-left">‚¨ÖÔ∏è</button>
      <button class="control-btn" id="btn-rotate">üîÑ</button>
      <button class="control-btn" id="btn-right">‚û°Ô∏è</button>
      <button class="control-btn" id="btn-drop">‚¨áÔ∏è</button>
    </div>
  </div>

  <button id="debug-btn">üêû DEBUG</button>
  <div id="debug-panel" class="hidden"></div>

  <div id="loading" class="overlay">
    <h1>Pintxos Tower</h1>
    <p>Á©ç„Åø‰∏ä„Åí„Çç„ÄÇËêΩ„Å®„Åó„Åü„ÇâË≤†„Åë„ÄÇ</p>
    <div class="pill" id="loading-text">LOADING...</div>
  </div>

  <div id="title-screen" class="overlay hidden">
    <h1 style="margin:0 0 8px 0; font-size:42px;">Pintxos Tower</h1>
    <p style="margin:0 0 18px 0; color:#333;">Á©ç„Åø‰∏ä„Åí„Çç„ÄÇËêΩ„Å®„Åó„Åü„ÇâË≤†„Åë„ÄÇ</p>
    <button class="primary-btn" id="btn-start">START</button>
  </div>

  <div id="game-over-screen" class="overlay hidden">
    <h1>GAME OVER</h1>
    <p>Score: <span id="final-score">0</span></p>
    <button class="primary-btn" id="btn-retry">„É™„Éà„É©„Ç§</button>
  </div>

<script>
(() => {
  "use strict";

  // ===== Â§öÈáçËµ∑ÂãïÈò≤Ê≠¢Ôºà„Åì„Çå„ÅåÁÑ°„ÅÑ„Å® ‚ÄúÂ§ßÈáè„Çπ„Éù„Éº„É≥ + UIÊ∂àÂ§±‚Äù „ÅåËµ∑„Åç„ÇãÔºâ =====
  if (window.__PT_BOOTED__) return;
  window.__PT_BOOTED__ = true;

  const {
    Engine, Render, Runner, Bodies, Composite, Events, Body, Common
  } = Matter;

  // ===== CONFIGÔºà„Åì„Åì„Å†„ÅëËß¶„Çå„Å∞Ë™øÊï¥„Åß„Åç„ÇãÔºâ =====
  const CONFIG = {
    ASSET_COUNT: 11,
    TEX_PATTERN: "img/{i}.png",
    MASK_PATTERN: "mask/{i}.png",

    groundHeightFromBottom: 180,
    groundWidthRatio: 0.75,
    groundThickness: 18,

    // Ë¶ã„ÅüÁõÆ„Çµ„Ç§„Ç∫ÔºàbboxÂü∫Ê∫ñ„ÅßÊèÉ„Åà„ÇãÔºâ
    targetMaxPx: 150,

    // ÂΩì„Åü„ÇäÂà§ÂÆö„ÅÆ‚ÄúË©∞„ÇÅÂÖ∑Âêà‚ÄùÔºà1.00=ÊäΩÂá∫„Åù„ÅÆ„Åæ„Åæ / 1.03„ÅßÈöôÈñì„ÅåÂüã„Åæ„Çä„ÇÑ„Åô„ÅÑÔºâ
    hitScale: 1.02,

    moveStep: 8,
    rotateStep: Math.PI / 10,

    // ËêΩ‰∏ãÂæå„Å´„ÄåÊ≠¢„Åæ„Å£„Åü„Äç„Å®Âà§ÂÆö„Åô„ÇãÊù°‰ª∂
    settleSpeed: 0.14,
    settleFrames: 18,

    // „Éü„ÇπÂà§ÂÆöÔºàÂú∞Èù¢„Çà„Çä„Åì„Çå„Å†„Åë‰∏ã„Å´ËêΩ„Å°„Åü„ÇâË≤†„ÅëÔºâ
    missExtra: 520,

    debugDefault: true
  };

  // ===== UI refs =====
  const elScore = document.getElementById("score-val");
  const elLoading = document.getElementById("loading");
  const elLoadingText = document.getElementById("loading-text");
  const elTitle = document.getElementById("title-screen");
  const elOver = document.getElementById("game-over-screen");
  const elFinal = document.getElementById("final-score");
  const elControls = document.getElementById("controls");
  const elDebugBtn = document.getElementById("debug-btn");
  const elDebugPanel = document.getElementById("debug-panel");

  const btnStart = document.getElementById("btn-start");
  const btnRetry = document.getElementById("btn-retry");

  const btnL = document.getElementById("btn-left");
  const btnR = document.getElementById("btn-right");
  const btnRot = document.getElementById("btn-rotate");
  const btnDrop = document.getElementById("btn-drop");

  // ===== debug toggle =====
  const qs = new URLSearchParams(location.search);
  let debugOn = qs.get("debug") === "1" || CONFIG.debugDefault || localStorage.getItem("PT_DEBUG") === "1";
  function setDebug(on) {
    debugOn = !!on;
    localStorage.setItem("PT_DEBUG", debugOn ? "1" : "0");
    elDebugPanel.classList.toggle("hidden", !debugOn);
  }
  elDebugBtn.addEventListener("click", () => setDebug(!debugOn));
  setDebug(debugOn);

  function logDebug(lines) {
    if (!debugOn) return;
    const text = Array.isArray(lines) ? lines.join("\n") : String(lines);
    elDebugPanel.textContent = text;
  }

  // ===== Engine/Render =====
  let engine, render, runner;
  let ground;
  let assets = [];
  let score = 0;
  let gameActive = false;

  let current = null;           // ÁèæÂú®Êìç‰Ωú„Åó„Å¶„ÅÑ„Çã„Éî„É≥„ÉÅ„Éß„Çπ
  let dropping = false;         // drop‰∏≠
  let settleCount = 0;          // settleÂà§ÂÆöÁî®

  // debug draw
  let drawPoly = true;

  // ===== helpers =====
  function size() { return { w: window.innerWidth, h: window.innerHeight }; }

  function ensureLibs() {
    const okMatter = !!Matter;
    const okDecomp = !!window.decomp;
    const okShape = !!window.ShapeExtract;
    return { okMatter, okDecomp, okShape };
  }

  async function unregisterSWIfAny() {
    try {
      if (!("serviceWorker" in navigator)) return;
      const regs = await navigator.serviceWorker.getRegistrations();
      if (regs.length && debugOn) {
        for (const r of regs) await r.unregister();
        console.log(`[SW] found ${regs.length} registrations -> unregister (debug)`);
      }
    } catch (e) {}
  }

  function createWorld() {
    const { w, h } = size();

    engine = Engine.create();
    engine.gravity.y = 1;

    // decomp enable
    if (Common && Common.setDecomp && window.decomp) Common.setDecomp(window.decomp);

    const root = document.getElementById("game-root");
    root.innerHTML = "";

    render = Render.create({
      element: root,
      engine,
      options: {
        width: w,
        height: h,
        wireframes: false,
        background: "#f0f0f0",
        pixelRatio: 1
      }
    });

    Render.run(render);

    runner = Runner.create();
    Runner.run(runner, engine);

    Events.on(engine, "beforeUpdate", updateLoop);
    Events.on(render, "afterRender", drawDebugOverlay);

    window.addEventListener("resize", onResize, { passive: true });
  }

  function onResize() {
    const { w, h } = size();
    render.canvas.width = w;
    render.canvas.height = h;
    Render.lookAt(render, { min: { x: 0, y: render.bounds.min.y }, max: { x: w, y: render.bounds.min.y + h } });
    createGround(); // ÁîªÈù¢ÂπÖ„Å´ËøΩÂæì
  }

  function createGround() {
    const { w, h } = size();
    if (ground) Composite.remove(engine.world, ground);

    const y = h - CONFIG.groundHeightFromBottom;
    const width = w * CONFIG.groundWidthRatio;

    ground = Bodies.rectangle(w / 2, y, width, CONFIG.groundThickness, {
      isStatic: true,
      label: "Ground",
      friction: 1.0,
      render: { fillStyle: "#8b4513" }
    });

    // Â£ÅÔºàËêΩ‰∏ã„Åó„ÇÑ„Åô„ÅïË™øÊï¥Áî®ÔºöÂøÖË¶Å„Å™„ÇâONÔºâ
    const wallL = Bodies.rectangle(-40, y - 800, 80, 2000, { isStatic: true, render: { visible: false }});
    const wallR = Bodies.rectangle(w + 40, y - 800, 80, 2000, { isStatic: true, render: { visible: false }});

    Composite.add(engine.world, [ground, wallL, wallR]);
  }

  function clearWorldKeepRenderer() {
    Composite.clear(engine.world, false);
    Engine.clear(engine);
    createGround();
  }

  // ===== spawn / body creation =====
  function pickAsset() {
    return assets[Math.floor(Math.random() * assets.length)];
  }

  function makeBodyFromAsset(asset, x, y) {
    const shape = asset.shape;
    const tex = asset.texUrl;

    // fallback rectÔºà„Åü„Å†„Åó‚ÄúÂãùÊâã„Å´„Åü„Åè„Åï„ÇìÂá∫„Çã‚ÄùÂéüÂõ†„Å´„ÅØ„Åó„Å™„ÅÑÔºâ
    function rectFallback(reason) {
      const bbox = shape.meta ? { w: shape.meta.cropW || 80, h: shape.meta.cropH || 50 } : { w: 80, h: 50 };
      const scale = CONFIG.targetMaxPx / Math.max(bbox.w, bbox.h);
      const bw = bbox.w * scale;
      const bh = bbox.h * scale;

      const body = Bodies.rectangle(x, y, bw, bh, {
        label: "Pintxo",
        restitution: 0.05,
        friction: 0.9,
        frictionStatic: 0.9,
        render: {
          sprite: { texture: tex, xScale: scale, yScale: scale, xOffset: 0.5, yOffset: 0.5 }
        }
      });

      body.__dbg = { fallback: true, reason, verts: 4, solid: (shape.solidRatio ?? 0), crop: `${bbox.w}x${bbox.h}`, offset: "0.5,0.5", scale };
      return body;
    }

    if (!shape || !shape.ok) {
      return rectFallback(shape?.reason || "shape missing");
    }

    const cropW = shape.crop.w, cropH = shape.crop.h;
    const scale = CONFIG.targetMaxPx / Math.max(cropW, cropH);

    // verts (centered) -> scale
    let verts = shape.verts.map(p => ({ x: p.x * scale * CONFIG.hitScale, y: p.y * scale * CONFIG.hitScale }));

    // Create body from vertices
    let body;
    try {
      body = Bodies.fromVertices(x, y, [verts], {
        label: "Pintxo",
        restitution: 0.05,
        friction: 0.9,
        frictionStatic: 0.9,
        render: {
          sprite: {
            texture: tex,
            xScale: scale,
            yScale: scale,
            xOffset: shape.offset.x,
            yOffset: shape.offset.y
          }
        }
      }, true);
    } catch (e) {
      body = null;
    }

    if (!body) {
      return rectFallback("fromVertices failed");
    }

    body.__dbg = {
      fallback: false,
      reason: "-",
      verts: shape.verts.length,
      solid: shape.solidRatio.toFixed(3),
      crop: `${cropW}x${cropH}`,
      offset: `${shape.offset.x.toFixed(3)},${shape.offset.y.toFixed(3)}`,
      scale
    };

    return body;
  }

  function spawnOne() {
    if (!gameActive) return;

    const { w } = size();
    const camTop = render.bounds.min.y;

    const asset = pickAsset();
    const x = w / 2;
    const y = camTop + 120;

    const body = makeBodyFromAsset(asset, x, y);
    Body.setStatic(body, true);

    body.__asset = asset;
    body.__isCurrent = true;
    body.__dropped = false;

    Composite.add(engine.world, body);

    current = body;
    dropping = false;
    settleCount = 0;

    if (debugOn) {
      logDebug([
        `[BOOT] debugOn=${debugOn}`,
        `[LIB] Matter=${!!Matter} decomp=${!!window.decomp} ShapeExtract=${!!window.ShapeExtract}`,
        ``,
        `Spawn`,
        `tex: ${asset.texUrl}`,
        `mask: ${asset.maskUrl}`,
        `ShapeExtract: ${window.ShapeExtract?.version || "?"}`,
        ``,
        `fallback: ${body.__dbg.fallback}`,
        `reason: ${body.__dbg.reason}`,
        `verts: ${body.__dbg.verts}`,
        `solidRatio: ${body.__dbg.solid}`,
        `crop: ${body.__dbg.crop}`,
        `spriteScale: ${body.__dbg.scale.toFixed(3)} hitScale:${CONFIG.hitScale.toFixed(2)}`,
        `offset: (${body.__dbg.offset})`,
      ]);
    }
  }

  // ===== camera / scoring / miss =====
  function topOfStackY() {
    let y = ground.position.y;
    for (const b of Composite.allBodies(engine.world)) {
      if (b.label === "Pintxo" && !b.__isCurrent) y = Math.min(y, b.position.y);
    }
    return y;
  }

  function updateCamera() {
    const { w, h } = size();
    const highestY = topOfStackY();
    const hasStack = highestY < ground.position.y;

    let targetTopY = 0;
    if (hasStack) targetTopY = highestY - h * 0.55;
    if (targetTopY > 0) targetTopY = 0;

    const curTopY = render.bounds.min.y;
    const nextTopY = curTopY + (targetTopY - curTopY) * 0.06;

    Render.lookAt(render, {
      min: { x: 0, y: nextTopY },
      max: { x: w, y: nextTopY + h }
    });
  }

  function addScoreFor(body) {
    const diff = ground.position.y - body.position.y;
    if (diff > 0) {
      score += Math.floor(diff / 10) + 10;
      elScore.textContent = score;
    }
  }

  function checkMiss() {
    const missLine = ground.position.y + CONFIG.missExtra;
    for (const b of Composite.allBodies(engine.world)) {
      if (b.label !== "Pintxo") continue;
      if (b.position.y > missLine) return true;
    }
    return false;
  }

  function updateLoop() {
    if (!gameActive) return;

    updateCamera();

    // missÂà§ÂÆöÔºà‰∏ã„Å´Ê∂à„Åà„Åü„ÇâË≤†„ÅëÔºâ
    if (checkMiss()) {
      gameOver();
      return;
    }

    // dropÂæå„ÅÆsettleÂà§ÂÆöÔºöÊ≠¢„Åæ„Å£„Åü„ÇâÊ¨°„Çíspawn
    if (current && dropping) {
      const v = current.velocity;
      const speed = Math.hypot(v.x, v.y);
      if (speed < CONFIG.settleSpeed) settleCount++;
      else settleCount = 0;

      if (settleCount >= CONFIG.settleFrames) {
        // current„ÇíÁ¢∫ÂÆö
        current.__isCurrent = false;
        addScoreFor(current);
        current = null;
        dropping = false;
        settleCount = 0;
        spawnOne();
      }
    }
  }

  function gameOver() {
    gameActive = false;
    elFinal.textContent = score;
    elControls.classList.add("hidden");
    elOver.classList.remove("hidden");
  }

  // ===== controls =====
  function move(dir) {
    if (!current || dropping) return;
    Body.translate(current, { x: dir * CONFIG.moveStep, y: 0 });
  }
  function rotate() {
    if (!current || dropping) return;
    Body.rotate(current, CONFIG.rotateStep);
  }
  function drop() {
    if (!current || dropping) return;
    dropping = true;
    current.__dropped = true;
    Body.setStatic(current, false);
  }

  function hold(btn, action) {
    let t = null;
    const start = (e) => { e.preventDefault(); action(); t = setInterval(action, 50); };
    const end = (e) => { e.preventDefault(); if (t) clearInterval(t); t = null; };
    btn.addEventListener("touchstart", start, { passive: false });
    btn.addEventListener("touchend", end, { passive: false });
    btn.addEventListener("mousedown", start);
    btn.addEventListener("mouseup", end);
    btn.addEventListener("mouseleave", end);
  }

  hold(btnL, () => move(-1));
  hold(btnR, () => move(1));
  btnRot.addEventListener("click", rotate);
  btnRot.addEventListener("touchstart", (e) => { e.preventDefault(); rotate(); }, { passive: false });
  btnDrop.addEventListener("click", drop);
  btnDrop.addEventListener("touchstart", (e) => { e.preventDefault(); drop(); }, { passive: false });

  btnStart.addEventListener("click", startGame);
  btnRetry.addEventListener("click", () => { elOver.classList.add("hidden"); startGame(); });

  // ===== debug overlay draw =====
  function drawDebugOverlay() {
    if (!debugOn || !drawPoly) return;
    const ctx = render.context;
    const bodies = Composite.allBodies(engine.world).filter(b => b.label === "Pintxo");
    ctx.save();
    ctx.lineWidth = 2;

    for (const b of bodies) {
      const verts = b.vertices;
      if (!verts || verts.length < 3) continue;
      ctx.beginPath();
      ctx.moveTo(verts[0].x, verts[0].y);
      for (let i = 1; i < verts.length; i++) ctx.lineTo(verts[i].x, verts[i].y);
      ctx.closePath();
      ctx.strokeStyle = b.__isCurrent ? "rgba(0,255,120,0.95)" : "rgba(0,180,255,0.35)";
      ctx.stroke();
    }
    ctx.restore();
  }

  // ===== game flow =====
  async function boot() {
    elLoading.classList.remove("hidden");
    elTitle.classList.add("hidden");
    elOver.classList.add("hidden");
    elControls.classList.add("hidden");
    elLoadingText.textContent = "LOADING...";

    const libs = ensureLibs();
    console.log(`[LIB] Matter=${libs.okMatter} decomp=${libs.okDecomp} ShapeExtract=${libs.okShape}`);

    if (!libs.okMatter || !libs.okDecomp || !libs.okShape) {
      elLoadingText.textContent = "LIB ERROR";
      logDebug([
        `[FATAL] library missing`,
        `Matter=${libs.okMatter}`,
        `decomp=${libs.okDecomp}`,
        `ShapeExtract=${libs.okShape}`,
        `‚Üí CDN„Åã„Éë„Çπ„ÇíÁ¢∫Ë™ç`
      ]);
      return;
    }

    await unregisterSWIfAny();

    createWorld();
    createGround();

    // preload shapes
    const ok = [];
    try {
      elLoadingText.textContent = "LOADING ASSETS...";
      assets = await ShapeExtract.preload({
        count: CONFIG.ASSET_COUNT,
        texPattern: CONFIG.TEX_PATTERN,
        maskPattern: CONFIG.MASK_PATTERN,
        log: ({ i, shape }) => {
          if (shape.ok) {
            console.log(`[ASSET OK] #${i} used=mask solid=${shape.solidRatio.toFixed(3)} verts=${shape.verts.length} crop=${shape.crop.w}x${shape.crop.h}`);
          } else {
            console.warn(`[ASSET NG] #${i} reason=${shape.reason}`);
          }
          ok.push(i);
          elLoadingText.textContent = `LOADING... (${ok.length}/${CONFIG.ASSET_COUNT})`;
        }
      });
    } catch (e) {
      elLoadingText.textContent = "ASSET LOAD FAILED";
      logDebug([`[FATAL] ${e.message}`, `ÁîªÂÉè„Éë„Çπ(img/.., mask/..)„ÇíÁ¢∫Ë™ç`]);
      return;
    }

    elLoading.classList.add("hidden");
    elTitle.classList.remove("hidden");
  }

  function startGame() {
    // UI
    elTitle.classList.add("hidden");
    elOver.classList.add("hidden");
    elControls.classList.remove("hidden");

    // reset
    clearWorldKeepRenderer();

    score = 0;
    elScore.textContent = score;

    gameActive = true;
    current = null;
    dropping = false;
    settleCount = 0;

    // camera reset
    const { w, h } = size();
    Render.lookAt(render, { min: { x: 0, y: 0 }, max: { x: w, y: h } });

    spawnOne();
  }

  // start
  boot();
})();
</script>
</body>
</html>
