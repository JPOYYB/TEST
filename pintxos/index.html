<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Pintxos Tower</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <script src="./shape-extract.js?v=11"></script>

  <style>
    body{margin:0;overflow:hidden;background:#f0f0f0;font-family:system-ui,-apple-system,Segoe UI,sans-serif;touch-action:none;}
    #game-root{position:fixed;inset:0;z-index:0;}
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block;}
    #ui-layer{position:fixed;inset:0;z-index:10;pointer-events:none;}
    #score-board{position:absolute;top:18px;left:18px;font-size:28px;font-weight:800;color:#222;text-shadow:2px 2px 0 #fff;}
    #controls{position:absolute;bottom:22px;left:0;width:100%;height:92px;display:flex;justify-content:center;align-items:center;gap:18px;pointer-events:auto;}
    .control-btn{width:64px;height:64px;background:rgba(255,255,255,.95);border:2px solid #888;border-radius:50%;font-size:26px;display:flex;align-items:center;justify-content:center;box-shadow:0 4px 10px rgba(0,0,0,.18);user-select:none;-webkit-user-select:none;}
    .control-btn:active{transform:translateY(2px);background:#e6e6e6;}
    #btn-drop{width:88px;height:88px;background:#ff4757;color:#fff;border:none;font-size:34px;}
    .overlay{position:fixed;inset:0;background:rgba(255,255,255,.96);display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:20;pointer-events:auto;}
    .hidden{display:none!important;}
    .primary-btn{padding:14px 36px;font-size:18px;background:#2ecc71;color:#fff;border:none;border-radius:999px;cursor:pointer;margin-top:14px;}
    #debug-btn{position:fixed;top:14px;right:14px;z-index:30;pointer-events:auto;background:#111;color:#fff;border:none;padding:10px 14px;border-radius:999px;box-shadow:0 6px 18px rgba(0,0,0,.25);font-weight:700;}
    #debug-panel{position:fixed;right:14px;top:64px;width:min(360px,calc(100vw - 28px));z-index:30;pointer-events:auto;background:rgba(20,20,20,.88);color:#fff;border-radius:16px;padding:14px;font-size:13px;line-height:1.35;white-space:pre-wrap;}
    #debug-panel.hidden{display:none!important;}
    #loading{text-align:center;}
    #loading h1{margin:0 0 6px 0;font-size:40px;}
    #loading p{margin:0 0 18px 0;color:#333;}
    #loading .pill{padding:14px 28px;border-radius:999px;background:#2ecc71;color:#fff;font-weight:800;}
  </style>
</head>

<body>
  <div id="game-root"></div>

  <div id="ui-layer">
    <div id="score-board">SCORE: <span id="score-val">0</span></div>
    <div id="controls" class="hidden">
      <button class="control-btn" id="btn-left">â¬…ï¸</button>
      <button class="control-btn" id="btn-rotate">ğŸ”„</button>
      <button class="control-btn" id="btn-right">â¡ï¸</button>
      <button class="control-btn" id="btn-drop">â¬‡ï¸</button>
    </div>
  </div>

  <button id="debug-btn">ğŸ DEBUG</button>
  <div id="debug-panel" class="hidden"></div>

  <div id="loading" class="overlay">
    <h1>Pintxos Tower</h1>
    <p>ç©ã¿ä¸Šã’ã‚ã€‚è½ã¨ã—ãŸã‚‰è² ã‘ã€‚</p>
    <div class="pill" id="loading-text">LOADING...</div>
  </div>

  <div id="title-screen" class="overlay hidden">
    <h1 style="margin:0 0 8px 0; font-size:42px;">Pintxos Tower</h1>
    <p style="margin:0 0 18px 0; color:#333;">ç©ã¿ä¸Šã’ã‚ã€‚è½ã¨ã—ãŸã‚‰è² ã‘ã€‚</p>
    <button class="primary-btn" id="btn-start">START</button>
  </div>

  <div id="game-over-screen" class="overlay hidden">
    <h1>GAME OVER</h1>
    <p>Score: <span id="final-score">0</span></p>
    <button class="primary-btn" id="btn-retry">ãƒªãƒˆãƒ©ã‚¤</button>
  </div>

<script>
(() => {
  "use strict";
  if (window.__PT_BOOTED__) return;
  window.__PT_BOOTED__ = true;

  const { Engine, Render, Runner, Bodies, Composite, Events, Body, Common, Sleeping } = Matter;

  // ===== CONFIGï¼ˆèª¿æ•´ãƒã‚¤ãƒ³ãƒˆã¯ã“ã“ã ã‘ï¼‰ =====
  const CONFIG = {
    ASSET_COUNT: 11,
    TEX_PATTERN: "img/{i}.png",
    MASK_PATTERN: "mask/{i}.png",

    groundHeightFromBottom: 180,
    groundWidthRatio: 0.75,
    groundThickness: 18,

    targetMaxPx: 150,   // è¦‹ãŸç›®ã‚µã‚¤ã‚º
    hitScale: 1.03,     // éš™é–“ãŒæ°—ã«ãªã‚‹ãªã‚‰ 1.04ã€œ1.06

    moveStep: 8,
    rotateStep: Math.PI / 10,

    // settleï¼ˆã€Œæ­¢ã¾ã£ãŸã€åˆ¤å®šï¼‰: touchedå¾Œã®ã¿
    settleSpeed: 0.16,
    settleFrames: 20,

    // 20ç§’ãƒ«ãƒ¼ãƒ«ï¼šã“ã“ã§å¼·åˆ¶ã‚¹ãƒªãƒ¼ãƒ—
    forceStopMs: 20000,

    // ãƒ–ãƒ«ãƒ–ãƒ«å¯¾ç­–
    frictionAir: 0.035,     // ç©ºæ°—æŠµæŠ—ï¼ˆä¸Šã’ã‚‹ã¨æ—©ãæ­¢ã¾ã‚‹ï¼‰
    sleepThreshold: 35,     // å°ã•ã„ã»ã©å¯ã‚„ã™ã„ï¼ˆæ­¢ã¾ã‚Šã‚„ã™ã„ï¼‰
    positionIterations: 7,  // å®‰å®šåŒ–ï¼ˆå¢—ã‚„ã—ã™ãæ³¨æ„ï¼‰
    velocityIterations: 6,

    missExtra: 520,

    debugDefault: true
  };

  const elScore = document.getElementById("score-val");
  const elLoading = document.getElementById("loading");
  const elLoadingText = document.getElementById("loading-text");
  const elTitle = document.getElementById("title-screen");
  const elOver = document.getElementById("game-over-screen");
  const elFinal = document.getElementById("final-score");
  const elControls = document.getElementById("controls");
  const elDebugBtn = document.getElementById("debug-btn");
  const elDebugPanel = document.getElementById("debug-panel");

  const btnStart = document.getElementById("btn-start");
  const btnRetry = document.getElementById("btn-retry");
  const btnL = document.getElementById("btn-left");
  const btnR = document.getElementById("btn-right");
  const btnRot = document.getElementById("btn-rotate");
  const btnDrop = document.getElementById("btn-drop");

  const qs = new URLSearchParams(location.search);
  let debugOn = qs.get("debug") === "1" || CONFIG.debugDefault || localStorage.getItem("PT_DEBUG") === "1";
  function setDebug(on){ debugOn=!!on; localStorage.setItem("PT_DEBUG",debugOn?"1":"0"); elDebugPanel.classList.toggle("hidden",!debugOn); }
  elDebugBtn.addEventListener("click",()=>setDebug(!debugOn));
  setDebug(debugOn);
  function logDebug(lines){ if(!debugOn) return; elDebugPanel.textContent = Array.isArray(lines)?lines.join("\n"):String(lines); }

  const size = ()=>({w:innerWidth,h:innerHeight});

  let engine, render, runner;
  let ground;
  let assets = [];
  let score = 0;
  let gameActive = false;

  let current = null;
  let dropping = false;
  let settleCount = 0;
  let spawning = false;   // ã‚¹ãƒãƒ¼ãƒ³å¤šé‡é˜²æ­¢

  function ensureLibs(){
    return { okMatter: !!Matter, okDecomp: !!window.decomp, okShape: !!window.ShapeExtract };
  }

  function createWorld(){
    const {w,h}=size();
    engine = Engine.create();
    engine.gravity.y = 1;

    // sleeping ONï¼ˆæ°¸ä¹…ãƒ–ãƒ«ãƒ–ãƒ«å¯¾ç­–ã®æœ¬ä¸¸ï¼‰
    engine.enableSleeping = true;
    engine.positionIterations = CONFIG.positionIterations;
    engine.velocityIterations = CONFIG.velocityIterations;

    if (Common && Common.setDecomp && window.decomp) Common.setDecomp(window.decomp);

    const root=document.getElementById("game-root");
    root.innerHTML="";
    render = Render.create({
      element: root,
      engine,
      options: { width:w, height:h, wireframes:false, background:"#f0f0f0", pixelRatio:1 }
    });
    Render.run(render);

    runner = Runner.create();
    Runner.run(runner, engine);

    Events.on(engine,"beforeUpdate",updateLoop);
    Events.on(render,"afterRender",drawDebugOverlay);
    Events.on(engine,"collisionStart",(ev)=>{
      if(!current) return;
      for(const p of ev.pairs){
        if(p.bodyA===current || p.bodyB===current){
          current.__touched = true; // â† touchedå¾Œã ã‘ settle ã™ã‚‹
        }
      }
    });

    addEventListener("resize",onResize,{passive:true});
  }

  function onResize(){
    const {w,h}=size();
    render.canvas.width=w; render.canvas.height=h;
    createGround();
  }

  function createGround(){
    const {w,h}=size();
    if(ground) Composite.remove(engine.world,ground);

    const y=h - CONFIG.groundHeightFromBottom;
    const width=w * CONFIG.groundWidthRatio;

    ground = Bodies.rectangle(w/2,y,width,CONFIG.groundThickness,{
      isStatic:true,label:"Ground",friction:1.0,render:{fillStyle:"#8b4513"}
    });
    const wallL=Bodies.rectangle(-40,y-800,80,2000,{isStatic:true,render:{visible:false}});
    const wallR=Bodies.rectangle(w+40,y-800,80,2000,{isStatic:true,render:{visible:false}});
    Composite.add(engine.world,[ground,wallL,wallR]);
  }

  function clearWorld(){
    Composite.clear(engine.world,false);
    Engine.clear(engine);
    createGround();
  }

  function pickAsset(){ return assets[(Math.random()*assets.length)|0]; }

  function makeBodyFromAsset(asset,x,y){
    const shape=asset.shape;
    const tex=asset.texUrl;

    function rectFallback(reason){
      const bbox = shape?.meta ? { w: shape.meta.cropW || 80, h: shape.meta.cropH || 50 } : { w:80, h:50 };
      const scale = CONFIG.targetMaxPx / Math.max(bbox.w,bbox.h);
      const body = Bodies.rectangle(x,y,bbox.w*scale,bbox.h*scale,{
        label:"Pintxo",
        restitution:0.05,
        friction:0.95,
        frictionStatic:0.95,
        frictionAir:CONFIG.frictionAir,
        sleepThreshold:CONFIG.sleepThreshold,
        render:{ sprite:{ texture:tex, xScale:scale, yScale:scale, xOffset:0.5, yOffset:0.5 } }
      });
      body.__dbg={fallback:true,reason,verts:4,solid:(shape?.solidRatio??0),offset:"0.5,0.5",scale};
      return body;
    }

    if(!shape || !shape.ok) return rectFallback(shape?.reason || "shape missing");

    const cropW=shape.crop.w, cropH=shape.crop.h;
    const scale = CONFIG.targetMaxPx / Math.max(cropW,cropH);

    const verts = shape.verts.map(p=>({ x:p.x*scale*CONFIG.hitScale, y:p.y*scale*CONFIG.hitScale }));

    let body;
    try{
      body = Bodies.fromVertices(x,y,[verts],{
        label:"Pintxo",
        restitution:0.05,
        friction:0.95,
        frictionStatic:0.95,
        frictionAir:CONFIG.frictionAir,
        sleepThreshold:CONFIG.sleepThreshold,
        render:{
          sprite:{
            texture:tex,
            xScale:scale, yScale:scale,
            xOffset:shape.offset.x, yOffset:shape.offset.y  // â† v11ã§ã€Œé‡å¿ƒoffsetã€ã«ãªã£ã¦ã‚ºãƒ¬ãŒæ¶ˆãˆã‚‹
          }
        }
      },true);
    }catch(e){ body=null; }

    if(!body) return rectFallback("fromVertices failed");

    body.__dbg={
      fallback:false,reason:"-",verts:shape.verts.length,
      solid:shape.solidRatio.toFixed(3),
      offset:`${shape.offset.x.toFixed(3)},${shape.offset.y.toFixed(3)}`,
      scale
    };
    return body;
  }

  function spawnOne(){
    if(!gameActive) return;
    if(spawning) return;
    if(current) return; // â† å¤šé‡ã‚¹ãƒãƒ¼ãƒ³é˜²æ­¢
    spawning = true;

    const {w}=size();
    const topY = render.bounds.min.y;
    const asset = pickAsset();

    const body = makeBodyFromAsset(asset, w/2, topY + 120);
    Body.setStatic(body,true);
    body.__asset=asset;
    body.__isCurrent=true;
    body.__touched=false;
    body.__dropAt=0;

    Composite.add(engine.world,body);
    current=body;
    dropping=false;
    settleCount=0;

    if(debugOn){
      logDebug([
        `Spawn`,
        `tex: ${asset.texUrl}`,
        `mask: ${asset.maskUrl}`,
        `ShapeExtract: ${window.ShapeExtract?.version || "?"}`,
        `fallback: ${body.__dbg.fallback} reason:${body.__dbg.reason}`,
        `verts:${body.__dbg.verts} solid:${body.__dbg.solid}`,
        `spriteScale:${body.__dbg.scale.toFixed(3)} hitScale:${CONFIG.hitScale.toFixed(2)}`,
        `offset:(${body.__dbg.offset})`,
      ]);
    }

    // é€£æ‰“ã§dropâ†’spawnãŒæš´ã‚Œãªã„ã‚ˆã†ã«å°‘ã—ã ã‘ãƒ­ãƒƒã‚¯
    setTimeout(()=>{ spawning=false; }, 250);
  }

  function topOfStackY(){
    let y=ground.position.y;
    for(const b of Composite.allBodies(engine.world)){
      if(b.label==="Pintxo" && !b.__isCurrent) y=Math.min(y,b.position.y);
    }
    return y;
  }

  function updateCamera(){
    const {w,h}=size();
    const highestY=topOfStackY();
    const hasStack=highestY<ground.position.y;

    let targetTopY=0;
    if(hasStack) targetTopY=highestY - h*0.55;
    if(targetTopY>0) targetTopY=0;

    const curTopY=render.bounds.min.y;
    const nextTopY=curTopY + (targetTopY-curTopY)*0.06;

    Render.lookAt(render,{min:{x:0,y:nextTopY},max:{x:w,y:nextTopY+h}});
  }

  function checkMiss(){
    const missLine=ground.position.y + CONFIG.missExtra;
    for(const b of Composite.allBodies(engine.world)){
      if(b.label!=="Pintxo") continue;
      if(b.position.y>missLine) return true;
    }
    return false;
  }

  function addScoreFor(body){
    const diff=ground.position.y - body.position.y;
    if(diff>0){ score += (diff/10|0) + 10; elScore.textContent=score; }
  }

  function forceStopCurrent(reason){
    if(!current) return;
    // touchedã—ã¦ãªã„ã®ã«20ç§’ãªã‚‰ã€ä½•ã‹ãŠã‹ã—ã„ï¼è½ã¡ã¦ã‚‹/ãƒãƒã£ã¦ã‚‹ â†’ è² ã‘æ‰±ã„ã§ã‚‚OKã ãŒã€
    // ã“ã“ã¯ã€Œæ­¢ã‚ã¦æ¬¡ã¸ã€ã§é€²ã‚ã‚‹
    Body.setVelocity(current,{x:0,y:0});
    Body.setAngularVelocity(current,0);
    Sleeping.set(current,true);

    current.__isCurrent=false;
    addScoreFor(current);

    current=null;
    dropping=false;
    settleCount=0;

    spawnOne();

    if(debugOn){
      logDebug([
        `FORCE STOP (${reason})`,
        `â†’ 20ç§’ä»¥å†…ã«å¿…ãšé€²è¡Œ`,
        `ï¼ˆæ°¸ä¹…ãƒ–ãƒ«ãƒ–ãƒ«é˜²æ­¢ï¼‰`
      ]);
    }
  }

  function updateLoop(){
    if(!gameActive) return;

    updateCamera();
    if(checkMiss()){ gameOver(); return; }

    // ã€Œæ­¢ã¾ã‚Šã‹ã‘ã€ã®ã‚„ã¤ã¯ç©æ¥µçš„ã«sleepã•ã›ã‚‹ï¼ˆå¾®æŒ¯å‹•ã‚’æ–­ã¡åˆ‡ã‚‹ï¼‰
    for(const b of Composite.allBodies(engine.world)){
      if(b.label!=="Pintxo") continue;
      if(b.__isCurrent) continue;
      const sp=Math.hypot(b.velocity.x,b.velocity.y);
      if(sp < 0.03 && Math.abs(b.angularVelocity) < 0.02){
        Sleeping.set(b,true);
      }
    }

    if(current && dropping){
      const now = performance.now();
      const elapsed = now - (current.__dropAt || now);

      // 20ç§’å¼·åˆ¶åœæ­¢
      if(elapsed > CONFIG.forceStopMs){
        forceStopCurrent("20s timeout");
        return;
      }

      // touchedå¾Œã®ã¿settleåˆ¤å®šï¼ˆç©ºä¸­ã§ã€Œæ­¢ã¾ã£ãŸæ‰±ã„ã€ã«ãªã‚‹äº‹æ•…é˜²æ­¢ï¼‰
      if(current.__touched){
        const v=current.velocity;
        const sp=Math.hypot(v.x,v.y);
        if(sp < CONFIG.settleSpeed && Math.abs(current.angularVelocity) < 0.06) settleCount++;
        else settleCount=0;

        if(settleCount >= CONFIG.settleFrames){
          // ç¢ºå®šã—ã¦æ¬¡ã¸
          Sleeping.set(current,true);
          current.__isCurrent=false;
          addScoreFor(current);

          current=null;
          dropping=false;
          settleCount=0;
          spawnOne();
        }
      }
    }
  }

  function drawDebugOverlay(){
    if(!debugOn) return;
    const ctx=render.context;
    const bodies=Composite.allBodies(engine.world).filter(b=>b.label==="Pintxo");
    ctx.save();
    ctx.lineWidth=2;
    for(const b of bodies){
      const v=b.vertices;
      if(!v||v.length<3) continue;
      ctx.beginPath();
      ctx.moveTo(v[0].x,v[0].y);
      for(let i=1;i<v.length;i++) ctx.lineTo(v[i].x,v[i].y);
      ctx.closePath();
      ctx.strokeStyle=b.__isCurrent ? "rgba(0,255,120,0.95)" : "rgba(0,180,255,0.35)";
      ctx.stroke();
    }
    ctx.restore();
  }

  function move(dir){
    if(!current || dropping) return;
    Body.translate(current,{x:dir*CONFIG.moveStep,y:0});
  }
  function rotate(){
    if(!current || dropping) return;
    Body.rotate(current,CONFIG.rotateStep);
  }
  function drop(){
    if(!current || dropping) return;
    dropping=true;
    current.__dropAt = performance.now();
    Body.setStatic(current,false);
  }

  function hold(btn,action){
    let t=null;
    const start=(e)=>{ e.preventDefault(); action(); t=setInterval(action,50); };
    const end=(e)=>{ e.preventDefault(); if(t) clearInterval(t); t=null; };
    btn.addEventListener("touchstart",start,{passive:false});
    btn.addEventListener("touchend",end,{passive:false});
    btn.addEventListener("mousedown",start);
    btn.addEventListener("mouseup",end);
    btn.addEventListener("mouseleave",end);
  }
  hold(btnL,()=>move(-1));
  hold(btnR,()=>move(1));
  btnRot.addEventListener("click",rotate);
  btnRot.addEventListener("touchstart",(e)=>{e.preventDefault();rotate();},{passive:false});
  btnDrop.addEventListener("click",drop);
  btnDrop.addEventListener("touchstart",(e)=>{e.preventDefault();drop();},{passive:false});

  btnStart.addEventListener("click",startGame);
  btnRetry.addEventListener("click",()=>{ elOver.classList.add("hidden"); startGame(); });

  function gameOver(){
    gameActive=false;
    elFinal.textContent=score;
    elControls.classList.add("hidden");
    elOver.classList.remove("hidden");
  }

  async function boot(){
    elLoading.classList.remove("hidden");
    elTitle.classList.add("hidden");
    elOver.classList.add("hidden");
    elControls.classList.add("hidden");
    elLoadingText.textContent="LOADING...";

    const libs=ensureLibs();
    if(!libs.okMatter || !libs.okDecomp || !libs.okShape){
      elLoadingText.textContent="LIB ERROR";
      logDebug([`[FATAL] libs missing`,`Matter=${libs.okMatter}`,`decomp=${libs.okDecomp}`,`ShapeExtract=${libs.okShape}`]);
      return;
    }

    createWorld();
    createGround();

    try{
      elLoadingText.textContent="LOADING ASSETS...";
      assets = await ShapeExtract.preload({
        count: CONFIG.ASSET_COUNT,
        texPattern: CONFIG.TEX_PATTERN,
        maskPattern: CONFIG.MASK_PATTERN,
        log: ({ i, shape }) => {
          if(shape.ok){
            console.log(`[ASSET OK] #${i} used=mask solid=${shape.solidRatio.toFixed(3)} verts=${shape.verts.length} crop=${shape.crop.w}x${shape.crop.h} comp=${shape.meta.compCount}`);
          }else{
            console.warn(`[ASSET NG] #${i} reason=${shape.reason}`);
          }
        }
      });
    }catch(e){
      elLoadingText.textContent="ASSET LOAD FAILED";
      logDebug([`[FATAL] ${e.message}`,`img/ ã¨ mask/ ã®ãƒ‘ã‚¹ã‚’ç¢ºèª`]);
      return;
    }

    elLoading.classList.add("hidden");
    elTitle.classList.remove("hidden");
  }

  function startGame(){
    elTitle.classList.add("hidden");
    elOver.classList.add("hidden");
    elControls.classList.remove("hidden");

    clearWorld();
    score=0; elScore.textContent=score;

    gameActive=true;
    current=null;
    dropping=false;
    settleCount=0;
    spawning=false;

    const {w,h}=size();
    Render.lookAt(render,{min:{x:0,y:0},max:{x:w,y:h}});

    spawnOne();
  }

  boot();
})();
</script>
</body>
</html>
