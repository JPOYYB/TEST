<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no" />
  <title>Pintxos Tower</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>

  <style>
    body{margin:0;overflow:hidden;background:#f0f0f0;font-family:system-ui,-apple-system,"Segoe UI",sans-serif;touch-action:none}
    canvas{display:block;position:fixed;top:0;left:0}
    #ui-layer{position:absolute;inset:0;pointer-events:none;z-index:10}
    #score-board{position:absolute;top:20px;left:20px;font-size:44px;font-weight:900;color:#333;text-shadow:2px 2px 0 #fff}
    #controls{position:absolute;bottom:30px;left:0;width:100%;height:120px;display:flex;justify-content:center;align-items:center;gap:26px;pointer-events:auto}
    .control-btn{width:90px;height:90px;background:rgba(255,255,255,.95);border:2px solid #888;border-radius:50%;font-size:34px;box-shadow:0 6px 10px rgba(0,0,0,.25);user-select:none;-webkit-user-select:none}
    .control-btn:active{background:#ddd;transform:translateY(2px)}
    #btn-drop{width:120px;height:120px;background:#ff4757;color:#fff;border:none;font-size:44px}
    .overlay{position:absolute;inset:0;background:rgba(255,255,255,.95);display:flex;flex-direction:column;justify-content:center;align-items:center;z-index:20;pointer-events:auto}
    .hidden{display:none!important}
    button.primary-btn{padding:15px 40px;font-size:18px;background:#2ecc71;color:#fff;border:none;border-radius:30px;margin-top:15px;cursor:pointer}
    #ranking-list{padding:0;list-style:none;margin-top:10px}
    #ranking-list li{margin:5px 0;border-bottom:1px solid #ddd;padding:5px;width:240px;display:flex;justify-content:space-between}

    /* Debug UI */
    #debugBtn{
      position:absolute;top:18px;right:18px;z-index:30;pointer-events:auto;
      background:#222;color:#fff;border:none;border-radius:999px;padding:10px 14px;
      box-shadow:0 8px 16px rgba(0,0,0,.25);font-weight:800;display:flex;gap:8px;align-items:center
    }
    #debugLayer{z-index:25;pointer-events:none;display:none}
    #debugCard{
      position:absolute;top:70px;right:18px;z-index:30;pointer-events:none;
      background:rgba(25,25,25,.86);color:#fff;border-radius:18px;padding:14px 14px;
      width:280px;white-space:pre-wrap;font:12px/1.35 ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;
      display:none
    }
  </style>
</head>
<body>

  <div id="ui-layer">
    <div id="score-board">SCORE: <span id="score-val">0</span></div>
    <div id="controls" class="hidden">
      <button class="control-btn" id="btn-left">â¬…ï¸</button>
      <button class="control-btn" id="btn-rotate">ğŸ”„</button>
      <button class="control-btn" id="btn-right">â¡ï¸</button>
      <button class="control-btn" id="btn-drop">â¬‡ï¸</button>
    </div>
  </div>

  <button id="debugBtn">ğŸ DEBUG</button>
  <div id="debugCard"></div>
  <canvas id="debugLayer"></canvas>

  <div id="title-screen" class="overlay">
    <h1>Pintxos Tower</h1>
    <p>ç”»åƒã‚’ç©ã¿ä¸Šã’ã‚ï¼</p>
    <button class="primary-btn" id="startBtn">START</button>
  </div>

  <div id="game-over-screen" class="overlay hidden">
    <h1>GAME OVER</h1>
    <p>Score: <span id="final-score">0</span></p>
    <div id="input-area">
      <input type="text" id="player-name" placeholder="åå‰ã‚’å…¥åŠ›" maxlength="8" style="padding:10px;font-size:16px;text-align:center">
      <br>
      <button class="primary-btn" id="saveBtn">ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç™»éŒ²</button>
      <br>
      <button style="margin-top:15px;background:none;border:none;text-decoration:underline;color:#666" id="retryBtn">ãƒªãƒˆãƒ©ã‚¤</button>
    </div>
    <div id="ranking-area" class="hidden">
      <h3>ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h3>
      <ul id="ranking-list"></ul>
      <button class="primary-btn" id="againBtn">ã‚‚ã†ä¸€åº¦</button>
    </div>
  </div>

  <script type="module">
    import { ShapeExtractor } from "./shape-extract.js";

    const {
      Engine, Render, Runner, Bodies, Composite, Events, Body, Vertices
    } = Matter;

    // === EDIT POINT #1: SETTINGSï¼ˆã“ã“ã ã‘è§¦ã‚Œã°èª¿æ•´ã§ãã‚‹ï¼‰ ===
    const SETTINGS = {
      imagesCount: 11,
      imgDir: "img",
      maskDir: "mask",
      targetMaxPx: 120,     // è¦‹ãŸç›®ã®æœ€å¤§ã‚µã‚¤ã‚ºï¼ˆå½“ãŸã‚Šåˆ¤å®šã‚‚åŒå€ç‡ï¼‰
      scaleClamp: { min: 0.85, max: 2.40 },
      gravityY: 1.0,
      groundFromBottom: 180,  // åœŸå°ã®é«˜ã•ï¼ˆä¸‹ã‹ã‚‰ï¼‰
      groundWidthRatio: 0.70, // åœŸå°ã®æ¨ªå¹…ï¼ˆç”»é¢å¹…ã®å‰²åˆï¼‰
      groundThickness: 20,

      moveStep: 7,
      rotateStep: Math.PI / 14,

      // å½“ãŸã‚Šåˆ¤å®šã®ã€Œè©°ã¾ã‚Šå…·åˆã€ï¼šéš™é–“ãŒæ°—ã«ãªã‚‹ãªã‚‰ 0.97ã€œ0.99 ã‚’æ¨å¥¨
      maskInset: 0.98,

      // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼åˆ¤å®šï¼šä¸‹ã«æ¶ˆãˆãŸã‚‰çµ‚ã‚ã‚Šï¼ˆè¡¨ç¤ºé ˜åŸŸã®ä¸‹+ã“ã®ä½™ç™½ï¼‰
      fallOutMargin: 260,

      // ç‰©ç†ç²¾åº¦ï¼ˆç©ã¿ã‚²ãƒ¼ã¯ä¸Šã’ãŸã»ã†ãŒãƒã‚·ï¼‰
      positionIterations: 12,
      velocityIterations: 10,
    };

    // === EDIT POINT #2: ASSETSï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åãƒ«ãƒ¼ãƒ«ï¼‰ ===
    const TEX = [];
    const MASK = [];
    for (let i = 1; i <= SETTINGS.imagesCount; i++) {
      TEX.push(`${SETTINGS.imgDir}/${i}.png`);
      MASK.push(`${SETTINGS.maskDir}/${i}.png`);
    }

    // --- engine/render ---
    let engine, render, runner;
    let ground;
    let current = null;
    let isDropping = false;
    let gameActive = false;
    let score = 0;
    let gameToken = 0;

    let W = window.innerWidth;
    let H = window.innerHeight;

    // shape extractor
    const extractor = new ShapeExtractor({
      alphaThreshold: 8,
      simplifyEps: 1.2,
      maxVerts: 80,
      inset: SETTINGS.maskInset,
      minArea: 120
    });

    // --- UI ---
    const $ = (id) => document.getElementById(id);
    const scoreVal = $("score-val");
    const titleScreen = $("title-screen");
    const gameOverScreen = $("game-over-screen");
    const controls = $("controls");
    const finalScore = $("final-score");
    const inputArea = $("input-area");
    const rankingArea = $("ranking-area");
    const rankingList = $("ranking-list");
    const debugBtn = $("debugBtn");
    const debugLayer = $("debugLayer");
    const debugCard = $("debugCard");

    // debug draw (never stops)
    let debug = false;

    function syncDebugCanvasSize() {
      debugLayer.width = render.canvas.width;
      debugLayer.height = render.canvas.height;
    }
    function worldToScreen(x, y) {
      const b = render.bounds;
      const cw = render.canvas.width;
      const ch = render.canvas.height;
      return {
        x: (x - b.min.x) * (cw / (b.max.x - b.min.x)),
        y: (y - b.min.y) * (ch / (b.max.y - b.min.y)),
      };
    }
    function drawDebug() {
      const ctx = debugLayer.getContext("2d");
      ctx.clearRect(0, 0, debugLayer.width, debugLayer.height);
      if (!debug) return;

      const bodies = Composite.allBodies(engine.world);
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#00ff6a";

      for (const b of bodies) {
        if (b.label !== "Pintxo") continue;
        const parts = (b.parts && b.parts.length > 1) ? b.parts.slice(1) : [b];

        for (const p of parts) {
          const vs = p.vertices;
          if (!vs || vs.length < 3) continue;
          ctx.beginPath();
          const p0 = worldToScreen(vs[0].x, vs[0].y);
          ctx.moveTo(p0.x, p0.y);
          for (let i = 1; i < vs.length; i++) {
            const pi = worldToScreen(vs[i].x, vs[i].y);
            ctx.lineTo(pi.x, pi.y);
          }
          ctx.closePath();
          ctx.stroke();
        }
      }
    }
    function startDebugLoop() {
      const loop = () => { drawDebug(); requestAnimationFrame(loop); };
      requestAnimationFrame(loop);
    }

    debugBtn.onclick = () => {
      debug = !debug;
      debugLayer.style.display = debug ? "block" : "none";
      debugCard.style.display = debug ? "block" : "none";
      syncDebugCanvasSize();
    };

    // --- init ---
    window.addEventListener("load", init);

    function init() {
      engine = Engine.create();
      engine.world.gravity.y = SETTINGS.gravityY;
      engine.positionIterations = SETTINGS.positionIterations;
      engine.velocityIterations = SETTINGS.velocityIterations;

      render = Render.create({
        element: document.body,
        engine,
        options: {
          width: W,
          height: H,
          background: "#f0f0f0",
          wireframes: false,
          pixelRatio: window.devicePixelRatio || 1
        }
      });
      Render.run(render);

      runner = Runner.create();
      Runner.run(runner, engine);

      createGround();
      Events.on(engine, "beforeUpdate", updateLoop);

      // debug loop (doesn't rely on afterRender)
      syncDebugCanvasSize();
      startDebugLoop();

      window.addEventListener("resize", () => {
        W = window.innerWidth; H = window.innerHeight;
        render.canvas.width = W;
        render.canvas.height = H;
        Render.lookAt(render, { min:{x:0,y:render.bounds.min.y}, max:{x:W,y:render.bounds.min.y+H} });
        syncDebugCanvasSize();
        createGround();
      });

      // buttons
      $("startBtn").onclick = () => startGame();
      $("retryBtn").onclick = () => startGame();
      $("againBtn").onclick = () => startGame();
      $("saveBtn").onclick = () => saveScore();

      bindControls();
    }

    function createGround() {
      if (ground) Composite.remove(engine.world, ground);

      const groundY = H - SETTINGS.groundFromBottom;
      const groundW = W * SETTINGS.groundWidthRatio;

      ground = Bodies.rectangle(W / 2, groundY, groundW, SETTINGS.groundThickness, {
        isStatic: true,
        label: "Ground",
        friction: 1.0,
        render: { fillStyle: "#8b4513" }
      });

      Composite.add(engine.world, ground);
    }

    async function startGame() {
      // UI
      titleScreen.classList.add("hidden");
      gameOverScreen.classList.add("hidden");
      controls.classList.remove("hidden");

      // reset world
      gameToken++;
      const myToken = gameToken;

      // remove old handlers to avoid duplicate loops after restart
      Events.off(engine, "beforeUpdate", updateLoop);

      Composite.clear(engine.world, false);
      Engine.clear(engine);

      engine = Engine.create();
      engine.world.gravity.y = SETTINGS.gravityY;
      engine.positionIterations = SETTINGS.positionIterations;
      engine.velocityIterations = SETTINGS.velocityIterations;

      render.engine = engine;
      Runner.stop(runner);
      runner = Runner.create();
      Runner.run(runner, engine);

      createGround();
      Render.lookAt(render, { min: { x: 0, y: 0 }, max: { x: W, y: H } });

      current = null;
      isDropping = false;
      gameActive = true;
      score = 0;
      scoreVal.textContent = String(score);

      Events.on(engine, "beforeUpdate", updateLoop);

      // prewarm shapes (non-blocking)
      (async () => {
        for (let i = 0; i < TEX.length; i++) {
          if (myToken !== gameToken) return;
          try { await extractor.load(TEX[i], MASK[i]); } catch {}
        }
      })();

      await spawnPintxo(myToken);
    }

    function gameOver() {
      if (!gameActive) return;
      gameActive = false;
      controls.classList.add("hidden");
      finalScore.textContent = String(score);
      gameOverScreen.classList.remove("hidden");
      inputArea.classList.remove("hidden");
      rankingArea.classList.add("hidden");
    }

    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

    async function spawnPintxo(token) {
      if (!gameActive || token !== gameToken) return;

      const idx = Math.floor(Math.random() * TEX.length);
      const texUrl = TEX[idx];
      const maskUrl = MASK[idx];

      const spawnX = W / 2;
      const spawnY = render.bounds.min.y + 120;

      let info;
      try {
        info = await extractor.load(texUrl, maskUrl);
      } catch (e) {
        info = { ok: false, reason: "load fail", imgW:100, imgH:100, bbox:{w:90,h:90}, centroid:{x:50,y:50}, solidRatio:0 };
      }

      // scale based on visible bbox (not full PNG padding)
      const base = Math.max(info?.bbox?.w ?? 100, info?.bbox?.h ?? 100);
      let k = SETTINGS.targetMaxPx / base;
      k = clamp(k, SETTINGS.scaleClamp.min, SETTINGS.scaleClamp.max);

      let body = null;
      let fallback = false;
      let reason = info?.reason ?? "-";

      if (info.ok && Array.isArray(info.verts) && info.verts.length >= 10) {
        const verts = info.verts.map(p => ({ x: p.x * k, y: p.y * k }));
        // sort clockwise for Matter
        Vertices.clockwiseSort(verts);

        body = Bodies.fromVertices(spawnX, spawnY, [verts], {
          label: "Pintxo",
          restitution: 0.05,
          friction: 0.95,
          frictionStatic: 1.0,
          render: {
            sprite: {
              texture: texUrl,
              xScale: k,
              yScale: k,
              // IMPORTANT: align sprite center to polygon (centroid in original image)
              xOffset: clamp(info.centroid.x / info.imgW, 0, 1),
              yOffset: clamp(info.centroid.y / info.imgH, 0, 1)
            }
          }
        }, true);

        if (!body) {
          fallback = true;
          reason = "fromVertices returned null";
        }
      } else {
        fallback = true;
      }

      if (fallback) {
        const bw = Math.max(18, (info?.bbox?.w ?? 90) * k);
        const bh = Math.max(18, (info?.bbox?.h ?? 60) * k);

        body = Bodies.rectangle(spawnX, spawnY, bw, bh, {
          label: "Pintxo",
          restitution: 0.05,
          friction: 0.95,
          frictionStatic: 1.0,
          render: {
            sprite: {
              texture: texUrl,
              xScale: k,
              yScale: k,
              xOffset: clamp((info?.centroid?.x ?? (info.imgW*0.5)) / (info?.imgW ?? 100), 0, 1),
              yOffset: clamp((info?.centroid?.y ?? (info.imgH*0.5)) / (info?.imgH ?? 100), 0, 1)
            }
          }
        });
      }

      Body.setStatic(body, true);   // æ“ä½œä¸­ã¯é™æ­¢
      body.isDropped = false;

      Composite.add(engine.world, body);
      current = body;
      isDropping = false;

      // debug card
      if (debug) {
        debugCard.textContent =
`Spawn
tex: ${texUrl}
mask: ${maskUrl}
ShapeExtract: v10

fallback: ${fallback}
reason: ${reason}
verts: ${info?.verts?.length ?? 0} parts: ${body?.parts?.length ?? 0}
solidRatio: ${(info?.solidRatio ?? 0).toFixed(3)}
spriteScale: ${k.toFixed(3)}
offset: (${(body.render?.sprite?.xOffset ?? 0.5).toFixed(3)}, ${(body.render?.sprite?.yOffset ?? 0.5).toFixed(3)})
hasDecomp: ${!!window.decomp}
meta: ${JSON.stringify(info?.meta ?? {})}`;
      }
    }

    function updateLoop() {
      if (!gameActive) return;

      // camera follow: keep stack in view
      const bodies = Composite.allBodies(engine.world);
      let minY = ground.position.y;
      for (const b of bodies) {
        if (b.label === "Pintxo" && b !== current) {
          if (b.position.y < minY) minY = b.position.y;
        }
      }
      // update score = max height reached (stable, no timeout)
      const height = Math.max(0, Math.floor((ground.position.y - minY) / 10));
      if (height > score) { score = height; scoreVal.textContent = String(score); }

      const targetTopY = Math.min(0, minY - (H * 0.55));
      const curTopY = render.bounds.min.y;
      const newY = curTopY + (targetTopY - curTopY) * 0.06;

      Render.lookAt(render, { min:{x:0,y:newY}, max:{x:W,y:newY+H} });

      // game over: if any dropped Pintxo goes below bottom of view
      const deadY = render.bounds.max.y + SETTINGS.fallOutMargin;
      for (const b of bodies) {
        if (b.label !== "Pintxo") continue;
        if (b === current) continue;
        if (b.position.y > deadY) {
          gameOver();
          break;
        }
      }
    }

    // --- controls ---
    function bindControls() {
      const btnL = $("btn-left");
      const btnR = $("btn-right");
      const btnRot = $("btn-rotate");
      const btnDrop = $("btn-drop");

      const hold = (btn, action) => {
        let t = null;
        const start = (e) => { e.preventDefault(); action(); t = setInterval(action, 50); };
        const end = (e) => { e.preventDefault(); if (t) clearInterval(t); t = null; };
        btn.addEventListener("touchstart", start, { passive:false });
        btn.addEventListener("touchend", end);
        btn.addEventListener("touchcancel", end);
        btn.addEventListener("mousedown", start);
        btn.addEventListener("mouseup", end);
        btn.addEventListener("mouseleave", end);
      };

      hold(btnL, () => move(-1));
      hold(btnR, () => move( 1));

      btnRot.addEventListener("click", rotate);
      btnRot.addEventListener("touchstart", (e)=>{e.preventDefault(); rotate();},{passive:false});

      btnDrop.addEventListener("click", drop);
      btnDrop.addEventListener("touchstart", (e)=>{e.preventDefault(); drop();},{passive:false});
    }

    function move(dir) {
      if (!current || isDropping) return;
      Body.translate(current, { x: dir * SETTINGS.moveStep, y: 0 });

      // clamp inside screen-ish
      const pad = 10;
      const minX = pad;
      const maxX = W - pad;
      const x = clamp(current.position.x, minX, maxX);
      Body.setPosition(current, { x, y: current.position.y });
    }

    function rotate() {
      if (!current || isDropping) return;
      Body.rotate(current, SETTINGS.rotateStep);
    }

    async function drop() {
      if (!current || isDropping) return;
      isDropping = true;

      Body.setStatic(current, false);
      current.isDropped = true;

      // spawn next after a short delay (avoid overlap)
      const token = gameToken;
      const prev = current;
      current = null;

      setTimeout(async () => {
        if (!gameActive || token !== gameToken) return;
        await spawnPintxo(token);
      }, 650);
    }

    // --- ranking ---
    function saveScore() {
      const name = ($("player-name").value || "åç„¡ã—").slice(0, 8);
      const data = JSON.parse(localStorage.getItem("pintxosRank") || "[]");
      data.push({ name, score });
      data.sort((a,b)=>b.score-a.score);
      localStorage.setItem("pintxosRank", JSON.stringify(data.slice(0, 5)));
      showRank();
    }
    function showRank() {
      const data = JSON.parse(localStorage.getItem("pintxosRank") || "[]");
      rankingList.innerHTML = "";
      data.forEach((d,i)=>{
        const li = document.createElement("li");
        li.innerHTML = `<span>${i+1}.${d.name}</span><span>${d.score}</span>`;
        rankingList.appendChild(li);
      });
      inputArea.classList.add("hidden");
      rankingArea.classList.remove("hidden");
    }
  </script>
</body>
</html>
