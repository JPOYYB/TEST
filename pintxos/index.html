<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Pintxos Tower</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <script src="./shape-extract.js"></script>

  <style>
    body{margin:0;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#f5f5f5;touch-action:none}
    canvas{position:fixed;inset:0;display:block}
    #ui{position:fixed;inset:0;pointer-events:none}
    #score{position:fixed;top:18px;left:18px;font-weight:900;font-size:40px;color:#222;text-shadow:0 2px 0 rgba(255,255,255,.8)}
    #controls{position:fixed;left:0;right:0;bottom:22px;display:flex;gap:18px;justify-content:center;align-items:center;pointer-events:auto}
    .btn{width:74px;height:74px;border-radius:999px;border:2px solid rgba(0,0,0,.25);background:rgba(255,255,255,.92);box-shadow:0 10px 20px rgba(0,0,0,.15);font-size:30px;display:grid;place-items:center;user-select:none;-webkit-user-select:none}
    .btn:active{transform:translateY(2px);filter:brightness(.95)}
    #drop{width:110px;height:110px;background:#ff4d57;color:#fff;border:none;font-size:38px}

    .overlay{position:fixed;inset:0;background:rgba(255,255,255,.96);display:flex;flex-direction:column;align-items:center;justify-content:center;gap:14px;z-index:50}
    .hidden{display:none !important}
    .title{font-size:40px;font-weight:900;letter-spacing:.02em}
    .sub{color:#444}
    .pill{padding:14px 44px;border-radius:999px;border:none;font-size:20px;font-weight:800;background:#2ecc71;color:#fff}
    .pill:disabled{background:#bfe9cc}

    #dbgBtn{position:fixed;top:16px;right:16px;z-index:80;pointer-events:auto;background:#222;color:#fff;border:none;border-radius:999px;padding:10px 14px;font-weight:800;box-shadow:0 10px 20px rgba(0,0,0,.2)}
    #dbgPanel{position:fixed;top:64px;right:16px;width:min(460px,calc(100vw - 32px));max-height:72vh;overflow:auto;z-index:80;background:rgba(20,20,20,.92);color:#fff;border-radius:16px;padding:14px;display:none;pointer-events:auto;box-shadow:0 20px 40px rgba(0,0,0,.25)}
    #dbgPanel pre{white-space:pre-wrap;word-break:break-word;font-size:12px;margin:0}
  </style>
</head>
<body>

  <div id="ui">
    <div id="score">SCORE: <span id="scoreVal">0</span></div>

    <div id="controls" class="hidden">
      <div class="btn" id="left">‚¨ÖÔ∏è</div>
      <div class="btn" id="rot">üîÑ</div>
      <div class="btn" id="right">‚û°Ô∏è</div>
      <div class="btn" id="drop">‚¨áÔ∏è</div>
    </div>
  </div>

  <button id="dbgBtn">üêû DEBUG</button>
  <div id="dbgPanel"><pre id="dbgText"></pre></div>

  <div id="title" class="overlay">
    <div class="title">Pintxos Tower</div>
    <div class="sub">Á©ç„Åø‰∏ä„Åí„Çç„ÄÇËêΩ„Å®„Åó„Åü„ÇâË≤†„Åë„ÄÇ</div>
    <button class="pill" id="startBtn" disabled>LOADING...</button>
    <div class="sub" id="loadHint" style="font-size:12px;color:#666">„É≠„Éº„Éâ‰∏≠‚Ä¶Ôºà?debug=1Ôºâ</div>
  </div>

  <div id="gameover" class="overlay hidden">
    <div class="title">GAME OVER</div>
    <div class="sub">Score: <span id="finalScore">0</span></div>
    <button class="pill" id="retryBtn">RETRY</button>
  </div>

<script>
(() => {
  "use strict";

  // ====== CONFIGÔºà„Åì„Åì„Å†„ÅëËß¶„Çå„Å∞OKÔºâ======
  const CONFIG = {
    BUILD_ID: "2026-01-01-CROP2",
    COUNT: 11,
    TEX_DIR: "./img",
    MASK_DIR: "./mask",
    USE_MASK_IF_EXISTS: true,

    DEBUG_DEFAULT: (new URLSearchParams(location.search).get("debug") === "1"),
    UNREGISTER_SW_ON_DEBUG: true,

    // Ë¶ã„ÅüÁõÆ„ÅÆ„Çµ„Ç§„Ç∫„ÅØ„Äå„Éà„É™„Éü„É≥„Ç∞Âæå„Äç„Å´Âêà„Çè„Åõ„ÇãÔºàÈáçË¶ÅÔºâ
    TARGET_MAX_PX: 150,

    // Áâ©ÁêÜÂΩì„Åü„ÇäÂà§ÂÆö„Çí„Åª„Çì„ÅÆÂ∞ë„ÅóÂ∞è„Åï„ÅèÔºà„Åæ„Å†ÈöôÈñì„ÅåÊÆã„ÇãÊôÇ„Å´Âäπ„ÅèÔºâ
    HIT_INSET: 0.98, // 1.00„ÅßÁÑ°Âäπ„ÄÇ0.95„Äú0.99„ÅßË™øÊï¥

    // shape extraction
    SHAPE: {
      sample: 180,
      alphaThreshold: 16,
      dilateIters: 1,
      minSolidRatio: 0.02,
      maxVerts: 64,
      minVerts: 12,
      timeoutMs: 12000,
      cropPadRatio: 0.06,   // bbox„ÇíÂ∞ë„ÅóÂ∫É„Åí„ÇãÔºà„Ç¢„É≥„ÉÅ„Ç®„Ç§„É™„Ç¢„ÇπÂê∏ÂèéÔºâ
      cropPadMinPx: 2,
      cropPadMaxPx: 24
    },

    MOVE_STEP: 7,
    ROT_STEP: Math.PI / 8,
    GROUND_Y_OFFSET: 180,
    GROUND_W_RATIO: 0.30,
    DEADLINE_EXTRA: 1.2,

    DRAW_COLLIDER_OUTLINE: true
  };

  // ====== UI ======
  const $ = (id) => document.getElementById(id);
  const startBtn = $("startBtn");
  const title = $("title");
  const gameover = $("gameover");
  const scoreVal = $("scoreVal");
  const finalScore = $("finalScore");
  const retryBtn = $("retryBtn");
  const dbgBtn = $("dbgBtn");
  const dbgPanel = $("dbgPanel");
  const dbgText = $("dbgText");

  let debugOn = CONFIG.DEBUG_DEFAULT;
  dbgPanel.style.display = debugOn ? "block" : "none";
  dbgBtn.addEventListener("click", () => {
    debugOn = !debugOn;
    dbgPanel.style.display = debugOn ? "block" : "none";
    dbgText.textContent = bootLogs.join("\n");
  });

  const bootLogs = [];
  function bootLog(s) {
    bootLogs.push(s);
    if (debugOn) dbgText.textContent = bootLogs.join("\n");
  }

  window.addEventListener("error", (e) => {
    bootLog(`[FATAL] ${e.message}`);
    if (e.error?.stack) bootLog(e.error.stack);
    startBtn.disabled = false;
    startBtn.textContent = "START (ERROR)";
    $("loadHint").textContent = "„Ç®„É©„Éº„ÄÇDEBUG„ÇíÈñã„ÅÑ„Å¶ÂéüÂõ†„ÇíË¶ã„Çã„ÄÇ";
  });
  window.addEventListener("unhandledrejection", (e) => {
    bootLog(`[FATAL] unhandledrejection: ${e.reason?.message ?? String(e.reason)}`);
    if (e.reason?.stack) bootLog(e.reason.stack);
    startBtn.disabled = false;
    startBtn.textContent = "START (ERROR)";
    $("loadHint").textContent = "Promise„ÅåËêΩ„Å°„Åü„ÄÇDEBUG„ÇíË¶ã„Çã„ÄÇ";
  });

  async function maybeUnregisterSW() {
    if (!CONFIG.UNREGISTER_SW_ON_DEBUG || !debugOn) return;
    if (!("serviceWorker" in navigator)) return;
    const regs = await navigator.serviceWorker.getRegistrations();
    if (regs.length) bootLog(`[SW] found ${regs.length} registrations -> unregister (debug)`);
    for (const r of regs) await r.unregister();
  }

  // ====== Matter ======
  const Engine = Matter.Engine,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Bodies = Matter.Bodies,
        Composite = Matter.Composite,
        Events = Matter.Events,
        Body = Matter.Body;

  let engine, render, runner;
  let w = innerWidth, h = innerHeight;
  let ground;
  let current = null;
  let isDropping = false;
  let gameActive = false;
  let score = 0;

  // assets: { spriteUrl, verts, meta, spriteScale }
  const assets = [];

  function assetUrl(path) { return `${path}?v=${encodeURIComponent(CONFIG.BUILD_ID)}`; }

  function createCanvas(w, h) {
    const c = document.createElement("canvas");
    c.width = w; c.height = h;
    return c;
  }

  function cropTextureToDataURL(texImg, meta) {
    // meta.cropX/Y/W/H „ÅØ SRCÂ∫ßÊ®ôÔºàpxÔºâ
    const cw = Math.max(2, Math.round(meta.cropW));
    const ch = Math.max(2, Math.round(meta.cropH));
    const cx = Math.round(meta.cropX);
    const cy = Math.round(meta.cropY);

    const c = createCanvas(cw, ch);
    const ctx = c.getContext("2d");
    ctx.clearRect(0,0,cw,ch);
    ctx.drawImage(texImg, cx, cy, cw, ch, 0, 0, cw, ch);

    // dataURLÔºàÂêå‰∏Ä„Ç™„É™„Ç∏„É≥ÂâçÊèê„ÄÇGitHub Pages„Å™„ÇâOKÔºâ
    return c.toDataURL("image/png");
  }

  function initPhysics() {
    bootLog(`[LIB] Matter=${!!window.Matter} decomp=${!!window.decomp} ShapeExtract=${!!window.ShapeExtract}`);
    if (window.decomp && Matter.Common?.setDecomp) Matter.Common.setDecomp(window.decomp);

    engine = Engine.create();
    render = Render.create({
      element: document.body,
      engine,
      options: {
        width: w,
        height: h,
        background: "#f5f5f5",
        wireframes: false,
        pixelRatio: devicePixelRatio || 1
      }
    });
    Render.run(render);

    runner = Runner.create();
    Runner.run(runner, engine);

    createGround();
    Render.lookAt(render, { min:{x:0,y:0}, max:{x:w,y:h} });

    Events.on(engine, "beforeUpdate", updateLoop);

    addEventListener("resize", () => {
      w = innerWidth; h = innerHeight;
      render.canvas.width = w;
      render.canvas.height = h;
      createGround();
    });
  }

  function createGround() {
    if (ground) Composite.remove(engine.world, ground);
    w = innerWidth; h = innerHeight;
    const groundY = h - CONFIG.GROUND_Y_OFFSET;
    const groundW = w * CONFIG.GROUND_W_RATIO;
    ground = Bodies.rectangle(w/2, groundY, groundW, 20, {
      isStatic: true,
      label: "Ground",
      render: { fillStyle:"#8b4513" },
      friction: 1.0
    });
    Composite.add(engine.world, ground);
  }

  function updateLoop() {
    if (!gameActive) return;

    const bodies = Composite.allBodies(engine.world);
    const deadLine = (render.bounds.min.y + h) * CONFIG.DEADLINE_EXTRA;

    for (const b of bodies) {
      if (b.label === "Pintxo" && b !== current) {
        if (b.position.y > deadLine) { gameOver(); return; }
      }
    }

    // camera follow
    let highestY = ground.position.y;
    let hasStack = false;
    for (const b of bodies) {
      if (b.label === "Pintxo" && b !== current) {
        if (b.position.y < highestY) { highestY = b.position.y; hasStack = true; }
      }
    }
    let targetTopY = 0;
    if (hasStack) targetTopY = highestY - (h * 0.55);
    if (targetTopY > 0) targetTopY = 0;

    const curTop = render.bounds.min.y;
    const nextTop = curTop + (targetTopY - curTop) * 0.06;
    Render.lookAt(render, { min:{x:0,y:nextTop}, max:{x:w,y:nextTop+h} });
  }

  function calcScore(body) {
    const diff = ground.position.y - body.position.y;
    if (diff > 0) score += Math.floor(diff / 10) + 10;
    scoreVal.textContent = String(score);
  }

  function pickAsset() {
    return assets[Math.floor(Math.random() * assets.length)];
  }

  function spawn() {
    if (!gameActive) return;
    if (!assets.length) { bootLog("[FATAL] no assets"); gameOver(); return; }

    const a = pickAsset();

    const spawnX = w/2;
    const spawnY = render.bounds.min.y + 120;

    const scaledVerts = a.verts.map(v => ({ x: v.x * a.spriteScale, y: v.y * a.spriteScale }));

    const body = Bodies.fromVertices(spawnX, spawnY, [scaledVerts], {
      label: "Pintxo",
      restitution: 0.05,
      friction: 0.9,
      frictionAir: 0.02,
      render: {
        sprite: {
          texture: a.spriteUrl,
          xScale: a.spriteScale,
          yScale: a.spriteScale,
          xOffset: a.meta.spriteOffset.x,
          yOffset: a.meta.spriteOffset.y
        }
      }
    }, true);

    if (!body) {
      bootLog(`[WARN] fromVertices null -> RECT fallback (should not happen)`);
      return;
    }

    if (CONFIG.HIT_INSET !== 1) {
      Body.scale(body, CONFIG.HIT_INSET, CONFIG.HIT_INSET);
    }

    if (debugOn && CONFIG.DRAW_COLLIDER_OUTLINE) {
      body.render.strokeStyle = "rgba(0,255,0,0.9)";
      body.render.lineWidth = 2;
    }

    Body.setStatic(body, true);
    current = body;
    isDropping = false;
    Composite.add(engine.world, body);

    if (debugOn) {
      bootLog("---- SPAWN ----");
      bootLog(`src: ${a.meta.srcW}x${a.meta.srcH} crop: ${a.meta.cropW}x${a.meta.cropH}`);
      bootLog(`solidRatio: ${a.meta.solidRatio.toFixed(3)} verts:${a.meta.vertsCount} offset:(${a.meta.spriteOffset.x.toFixed(3)},${a.meta.spriteOffset.y.toFixed(3)})`);
      bootLog(`spriteScale:${a.spriteScale.toFixed(3)} hitInset:${CONFIG.HIT_INSET}`);
    }
  }

  function move(dir) {
    if (current && !isDropping) Body.translate(current, { x: dir * CONFIG.MOVE_STEP, y: 0 });
  }
  function rotate() {
    if (current && !isDropping) Body.rotate(current, CONFIG.ROT_STEP);
  }
  function drop() {
    if (!current || isDropping) return;
    isDropping = true;
    Body.setStatic(current, false);
    const dropped = current;

    const t0 = performance.now();
    const check = () => {
      if (!gameActive) return;
      const v = dropped.velocity;
      const speed = Math.hypot(v.x, v.y);
      const ang = Math.abs(dropped.angularVelocity);

      if ((speed < 0.15 && ang < 0.15) || (performance.now() - t0 > 2200)) {
        calcScore(dropped);
        spawn();
      } else {
        requestAnimationFrame(check);
      }
    };
    requestAnimationFrame(check);
  }

  // controls
  const hold = (el, fn) => {
    let t = null;
    const start = (e) => { e.preventDefault(); fn(); t = setInterval(fn, 50); };
    const end = (e) => { e.preventDefault(); if (t) clearInterval(t); t = null; };
    el.addEventListener("touchstart", start, { passive:false });
    el.addEventListener("touchend", end);
    el.addEventListener("touchcancel", end);
    el.addEventListener("mousedown", start);
    el.addEventListener("mouseup", end);
    el.addEventListener("mouseleave", end);
  };

  function bindControls() {
    hold($("left"), () => move(-1));
    hold($("right"), () => move(1));
    $("rot").addEventListener("click", rotate);
    $("rot").addEventListener("touchstart", (e)=>{ e.preventDefault(); rotate(); }, { passive:false });
    $("drop").addEventListener("click", drop);
    $("drop").addEventListener("touchstart", (e)=>{ e.preventDefault(); drop(); }, { passive:false });
  }

  function startGame() {
    title.classList.add("hidden");
    gameover.classList.add("hidden");
    $("controls").classList.remove("hidden");

    Composite.clear(engine.world, false);
    Engine.clear(engine);

    score = 0;
    scoreVal.textContent = "0";
    gameActive = true;

    createGround();
    Render.lookAt(render, { min:{x:0,y:0}, max:{x:w,y:h} });

    spawn();
  }

  function gameOver() {
    gameActive = false;
    $("controls").classList.add("hidden");
    finalScore.textContent = String(score);
    gameover.classList.remove("hidden");
  }

  retryBtn.addEventListener("click", startGame);
  startBtn.addEventListener("click", startGame);

  async function preloadAssets() {
    bootLog(`[BOOT] debugOn=${debugOn}`);
    await maybeUnregisterSW();

    const logger = [];
    let fail = 0;

    for (let i = 1; i <= CONFIG.COUNT; i++) {
      const texUrl = assetUrl(`${CONFIG.TEX_DIR}/${i}.png`);
      const maskUrl = CONFIG.USE_MASK_IF_EXISTS ? assetUrl(`${CONFIG.MASK_DIR}/${i}.png`) : null;

      let texImg;
      try {
        texImg = await ShapeExtract.loadImage(texUrl, 8000);
      } catch (e) {
        fail++;
        bootLog(`[ASSET NG] tex missing #${i}: ${e.message}`);
        continue;
      }

      const res = await ShapeExtract.extract({
        srcUrl: texUrl,
        maskUrl,
        sample: CONFIG.SHAPE.sample,
        alphaThreshold: CONFIG.SHAPE.alphaThreshold,
        dilateIters: CONFIG.SHAPE.dilateIters,
        minSolidRatio: CONFIG.SHAPE.minSolidRatio,
        maxVerts: CONFIG.SHAPE.maxVerts,
        minVerts: CONFIG.SHAPE.minVerts,
        timeoutMs: CONFIG.SHAPE.timeoutMs,
        cropPadRatio: CONFIG.SHAPE.cropPadRatio,
        cropPadMinPx: CONFIG.SHAPE.cropPadMinPx,
        cropPadMaxPx: CONFIG.SHAPE.cropPadMaxPx,
        logger
      });

      if (res.meta.fallback || !res.verts) {
        fail++;
        bootLog(`[ASSET NG] #${i} fallback=${res.meta.fallback} reason=${res.meta.reason}`);
        continue;
      }

      // ‚òÖ„Åì„Åì„ÅåÊú¨ÂëΩÔºöcrop„Åó„Åü„ÉÜ„ÇØ„Çπ„ÉÅ„É£„Çísprite„Å´‰Ωø„ÅÜÔºàÈÄèÊòé‰ΩôÁôΩ„ÅåÊ∂à„Åà„ÇãÔºâ
      const spriteUrl = cropTextureToDataURL(texImg, res.meta);

      // spriteScale„ÅØ„ÄåcropÂæå„Çµ„Ç§„Ç∫„Äç„Å´Âêà„Çè„Åõ„ÇãÔºàÈáçË¶ÅÔºâ
      const spriteScale = CONFIG.TARGET_MAX_PX / Math.max(res.meta.cropW, res.meta.cropH);

      assets.push({
        spriteUrl,
        verts: res.verts,
        meta: res.meta,
        spriteScale
      });

      bootLog(`[ASSET OK] #${i} used=${res.meta.used} solid=${res.meta.solidRatio.toFixed(3)} verts=${res.meta.vertsCount} crop=${res.meta.cropW}x${res.meta.cropH}`);
    }

    bootLog(`[DONE] assets=${assets.length}/${CONFIG.COUNT} fail=${fail}`);
    dbgText.textContent = bootLogs.join("\n");

    if (!assets.length) {
      $("loadHint").textContent = "1Êûö„ÇÇË™≠„ÇÅ„Å¶„Å™„ÅÑ„ÄÇimg/ „Å® mask/ „ÅÆ„Éë„ÇπÁ¢∫Ë™ç„ÄÇ";
      startBtn.disabled = false;
      startBtn.textContent = "START (NO ASSET)";
      return;
    }

    startBtn.disabled = false;
    startBtn.textContent = "START";
    $("loadHint").textContent = debugOn ? "„É≠„Éº„ÉâÁµêÊûú„ÅØDEBUG„Å´Ë°®Á§∫‰∏≠" : "Ê∫ñÂÇôÂÆå‰∫Ü";
  }

  // boot
  bindControls();
  initPhysics();
  preloadAssets();

})();
</script>
</body>
</html>
