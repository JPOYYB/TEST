<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Pintxos Tower</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>

  <style>
    body { margin: 0; padding: 0; overflow: hidden; background-color: #f0f0f0; font-family: sans-serif; touch-action: none; }
    canvas { display: block; position: fixed; top: 0; left: 0; z-index: 0; }
    #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    #score-board { position: absolute; top: 20px; left: 20px; font-size: 24px; font-weight: bold; color: #333; text-shadow: 2px 2px 0px white; }

    #controls {
      position: absolute; bottom: 30px; left: 0; width: 100%; height: 90px;
      display: flex; justify-content: center; align-items: center; gap: 20px;
      pointer-events: auto;
    }
    .control-btn {
      width: 60px; height: 60px;
      background: rgba(255,255,255,0.9);
      border: 2px solid #888; border-radius: 50%;
      font-size: 24px; cursor: pointer;
      display: flex; justify-content: center; align-items: center;
      box-shadow: 0 4px 5px rgba(0,0,0,0.2);
      user-select: none; -webkit-user-select: none;
    }
    .control-btn:active { background: #ccc; transform: translateY(2px); }
    #btn-drop { width: 80px; height: 80px; background: #ff4757; color: white; border: none; font-size: 32px; }

    .overlay {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(255,255,255,0.95);
      display: flex; flex-direction: column; justify-content: center; align-items: center;
      z-index: 20; pointer-events: auto;
    }
    .hidden { display: none !important; }
    button.primary-btn { padding: 15px 40px; font-size: 18px; background: #2ecc71; color: white; border: none; border-radius: 30px; margin-top: 15px; cursor: pointer; }
    #ranking-list { padding: 0; list-style: none; margin-top:10px; }
    #ranking-list li { margin: 5px 0; border-bottom: 1px solid #ddd; padding: 5px; width: 220px; display:flex; justify-content:space-between; }
  </style>
</head>

<body>
  <div id="ui-layer">
    <div id="score-board">SCORE: <span id="score-val">0</span></div>
    <div id="controls" class="hidden">
      <button class="control-btn" id="btn-left">â¬…ï¸</button>
      <button class="control-btn" id="btn-rotate">ğŸ”„</button>
      <button class="control-btn" id="btn-right">â¡ï¸</button>
      <button class="control-btn" id="btn-drop">â¬‡ï¸</button>
    </div>
  </div>

  <div id="title-screen" class="overlay">
    <h1>Pintxos Tower</h1>
    <p>ç”»åƒã‚’ç©ã¿ä¸Šã’ã‚ï¼</p>
    <button class="primary-btn" onclick="startGame()">START</button>
  </div>

  <div id="game-over-screen" class="overlay hidden">
    <h1>GAME OVER</h1>
    <p>Score: <span id="final-score">0</span></p>
    <div id="input-area">
      <input type="text" id="player-name" placeholder="åå‰ã‚’å…¥åŠ›" maxlength="8" style="padding:10px; font-size:16px; text-align:center;">
      <br>
      <button class="primary-btn" onclick="saveScore()">ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç™»éŒ²</button>
      <br>
      <button style="margin-top:15px; background:none; border:none; text-decoration:underline; color:#666;" onclick="resetGame()">ãƒªãƒˆãƒ©ã‚¤</button>
    </div>
    <div id="ranking-area" class="hidden">
      <h3>ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h3>
      <ul id="ranking-list"></ul>
      <button class="primary-btn" onclick="resetGame()">ã‚‚ã†ä¸€åº¦</button>
    </div>
  </div>

<script>
  // poly-decomp ã‚’ Matter.js ã«æ¸¡ã™ï¼ˆå‡¹å½¢çŠ¶ã®åˆ†è§£ã«å¿…é ˆï¼‰
  window.decomp = decomp;

  const Engine = Matter.Engine,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Bodies = Matter.Bodies,
        Composite = Matter.Composite,
        Events = Matter.Events,
        Body = Matter.Body;

  let engine, render, runner;
  let ground;
  let currentPintxo = null;
  let isDropping = false;
  let gameActive = false;
  let score = 0;

  const IMAGES = [];
  for (let i = 1; i <= 11; i++) IMAGES.push(`./img/${i}.png`);

  let w = window.innerWidth;
  let h = window.innerHeight;

  // ===== å½¢çŠ¶æŠ½å‡ºè¨­å®šï¼ˆã“ã“ã ã‘è§¦ã‚Œã°ãƒãƒ¥ãƒ¼ãƒ‹ãƒ³ã‚°å¯èƒ½ï¼‰ =====
  const SHAPE_CFG = {
    threshold: 30,      // åŠé€æ˜ã®ç¸ã‚’åˆ‡ã‚‹ï¼šè–„ã„ç¸ãŒå¤šã„ãªã‚‰ä¸Šã’ã‚‹(30â†’40)ã€æ¬ ã‘ã‚‹ãªã‚‰ä¸‹ã’ã‚‹(30â†’20)
    sampleScale: 0.40,  // è¼ªéƒ­æŠ½å‡ºã®è§£åƒåº¦ï¼šç²¾å¯†ã«ã—ãŸã„ãªã‚‰ä¸Šã’ã‚‹(0.40â†’0.50)ã€é‡ã„ãªã‚‰ä¸‹ã’ã‚‹(0.40â†’0.30)
    simplifyEps: 1.4,   // è¼ªéƒ­ã®é–“å¼•ãï¼šç´°éƒ¨ã‚’æ®‹ã™ãªã‚‰ä¸‹ã’ã‚‹(1.4â†’1.0)ã€è»½ãã™ã‚‹ãªã‚‰ä¸Šã’ã‚‹(1.4â†’2.0)
    maxVertices: 220    // æœ€å¤§é ‚ç‚¹æ•°ï¼šç²¾å¯†ã«ã—ãŸã„ãªã‚‰å¢—ã‚„ã™(220â†’300)ã€é‡ã„ãªã‚‰æ¸›ã‚‰ã™(220â†’140)
  };

  // è¦‹ãŸç›®ã‚µã‚¤ã‚ºã‚’çµ±ä¸€ï¼ˆpxç›¸å½“ï¼‰
  const TARGET_SIZE = 115;  // ã“ã“ã‚’ä¸Šã’ã‚‹ã¨ãƒ”ãƒ³ãƒãƒ§ã‚¹ãŒå¤§ãããªã‚‹
  const HIT_INSET   = 0.96; // å½“ãŸã‚Šåˆ¤å®šã ã‘å°‘ã—å°ã•ãï¼šç©ºä¸­è¡çªãŒã‚ã‚‹ãªã‚‰0.92ã€ã™ã‚ŠæŠœã‘ã‚‹ãªã‚‰0.98

  // ===== é€éPNG(ã‚¢ãƒ«ãƒ•ã‚¡) â†’ å¤–å‘¨è¼ªéƒ­æŠ½å‡º =====
  const shapeCache = new Map(); // imgPath -> { pts, iw, ih }

  function loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }

  function polygonArea(pts) {
    let a = 0;
    for (let i = 0; i < pts.length; i++) {
      const p = pts[i], q = pts[(i + 1) % pts.length];
      a += (p.x * q.y - q.x * p.y);
    }
    return a / 2;
  }

  // Moore neighbor tracingï¼ˆå¤–å‘¨è¼ªéƒ­ã®ãƒˆãƒ¬ãƒ¼ã‚¹ï¼‰
  function traceMoore(boundary, W, H, sx, sy) {
    const dirs = [
      {x: 1, y: 0}, {x: 1, y: 1}, {x: 0, y: 1}, {x:-1, y: 1},
      {x:-1, y: 0}, {x:-1, y:-1},{x: 0, y:-1},{x: 1, y:-1}
    ];
    let x = sx, y = sy;
    let bx = sx - 1, by = sy; // backtrack
    const startX = x, startY = y;
    const out = [];
    const safety = W * H * 8;
    let steps = 0;

    const dirIndex = (dx, dy) => {
      for (let i = 0; i < dirs.length; i++) if (dirs[i].x === dx && dirs[i].y === dy) return i;
      return 0;
    };

    do {
      out.push({x, y});
      const bi = dirIndex(x - bx, y - by);
      let found = false;

      for (let k = 0; k < 8; k++) {
        const idx = (bi + 1 + k) % 8;
        const nx = x + dirs[idx].x, ny = y + dirs[idx].y;
        if (nx < 0 || nx >= W || ny < 0 || ny >= H) continue;
        if (boundary[ny * W + nx]) {
          const pb = (idx + 7) % 8;
          bx = x + dirs[pb].x; by = y + dirs[pb].y;
          x = nx; y = ny;
          found = true;
          break;
        }
      }
      if (!found) break;

      steps++;
      if (steps > safety) break;
    } while (!(x === startX && y === startY));

    return out;
  }

  // RDP ç°¡æ˜“ï¼ˆé ‚ç‚¹å‰Šæ¸›ï¼‰
  function rdpSimplify(points, eps) {
    if (points.length < 3) return points;

    const sq = (x) => x * x;
    const dist2 = (p, a, b) => {
      const vx = b.x - a.x, vy = b.y - a.y;
      const wx = p.x - a.x, wy = p.y - a.y;
      const c1 = vx * wx + vy * wy;
      if (c1 <= 0) return sq(p.x - a.x) + sq(p.y - a.y);
      const c2 = vx * vx + vy * vy;
      if (c2 <= c1) return sq(p.x - b.x) + sq(p.y - b.y);
      const t = c1 / c2;
      const px = a.x + t * vx, py = a.y + t * vy;
      return sq(p.x - px) + sq(p.y - py);
    };
    const eps2 = eps * eps;

    function rec(pts) {
      let maxD = 0, idx = -1;
      const a = pts[0], b = pts[pts.length - 1];
      for (let i = 1; i < pts.length - 1; i++) {
        const d = dist2(pts[i], a, b);
        if (d > maxD) { maxD = d; idx = i; }
      }
      if (maxD > eps2) {
        const left = rec(pts.slice(0, idx + 1));
        const right = rec(pts.slice(idx));
        return left.slice(0, -1).concat(right);
      }
      return [a, b];
    }

    // è¼ªéƒ­ã¯é–‰æ›²ç·šãªã®ã§ã€ç°¡æ˜“çš„ã«ãã®ã¾ã¾å®Ÿè¡Œï¼ˆéå‰°ç°¡ç•¥åŒ–ã‚’é¿ã‘ãŸã„ãªã‚‰å¾Œã§å¼·åŒ–å¯ï¼‰
    return rec(points);
  }

  function capVertices(pts, maxV) {
    if (pts.length <= maxV) return pts;
    const step = pts.length / maxV;
    const out = [];
    for (let i = 0; i < maxV; i++) out.push(pts[Math.floor(i * step)]);
    return out;
  }

  // é€éPNGã®ã‚¢ãƒ«ãƒ•ã‚¡ã‹ã‚‰ã€Œå¤–å‘¨è¼ªéƒ­ã€ã‚’æŠ½å‡ºã—ã¦ Matter.js ã®é ‚ç‚¹åˆ—ã«ã™ã‚‹
  // â˜…ä¸­å¿ƒã¯ã€Œç”»åƒä¸­å¿ƒã€ã§ã¯ãªãã€Œå®Ÿä½“ï¼ˆã‚¢ãƒ«ãƒ•ã‚¡é ˜åŸŸï¼‰ã®ä¸­å¿ƒã€ã«åˆã‚ã›ã‚‹
  async function extractShapeFromAlpha(imgPath) {
    if (shapeCache.has(imgPath)) return shapeCache.get(imgPath);

    const img = await loadImage(imgPath);
    const iw = img.naturalWidth, ih = img.naturalHeight;

    const ss = SHAPE_CFG.sampleScale;
    const W = Math.max(24, Math.floor(iw * ss));
    const H = Math.max(24, Math.floor(ih * ss));

    const cvs = document.createElement("canvas");
    cvs.width = W; cvs.height = H;
    const ctx = cvs.getContext("2d", { willReadFrequently: true });
    ctx.clearRect(0, 0, W, H);
    ctx.drawImage(img, 0, 0, W, H);

    const data = ctx.getImageData(0, 0, W, H).data;
    const mask = new Uint8Array(W * H);

    let solid = 0;
    let minX = W, minY = H, maxX = -1, maxY = -1;

    const thr = SHAPE_CFG.threshold;

    for (let y = 0; y < H; y++) {
      for (let x = 0; x < W; x++) {
        const i = (y * W + x) * 4;
        const a = data[i + 3];
        if (a > thr) {
          mask[y * W + x] = 1;
          solid++;
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }
      }
    }
    if (solid < 30) return null;

    // å¢ƒç•ŒæŠ½å‡ºï¼ˆ4è¿‘å‚ï¼‰
    const boundary = new Uint8Array(W * H);
    let sx = -1, sy = -1;
    for (let y = 1; y < H - 1; y++) {
      for (let x = 1; x < W - 1; x++) {
        const idx = y * W + x;
        if (!mask[idx]) continue;
        if (!mask[idx - 1] || !mask[idx + 1] || !mask[idx - W] || !mask[idx + W]) {
          boundary[idx] = 1;
          // startã¯ã€Œæœ€ä¸Šãƒ»æœ€å·¦ã€å„ªå…ˆ
          if (sy === -1 || y < sy || (y === sy && x < sx)) { sx = x; sy = y; }
        }
      }
    }
    if (sx === -1) return null;

    const contour = traceMoore(boundary, W, H, sx, sy);
    if (!contour || contour.length < 20) return null;

    // â˜…ä¸­å¿ƒã‚’ã€Œå®Ÿä½“ã®BBoxä¸­å¿ƒã€ã«åˆã‚ã›ã‚‹ï¼ˆé€æ˜ä½™ç™½ãŒã‚ã£ã¦ã‚‚ä¸€è‡´ï¼‰
    const cx = (minX + maxX) / 2;
    const cy = (minY + maxY) / 2;

    const inv = 1 / ss;
    let pts = contour.map(p => ({
      x: (p.x - cx) * inv,
      y: (p.y - cy) * inv
    }));

    pts = rdpSimplify(pts, SHAPE_CFG.simplifyEps * inv);
    pts = capVertices(pts, SHAPE_CFG.maxVertices);

    if (pts.length < 8) return null;
    if (polygonArea(pts) > 0) pts.reverse(); // clockwiseæƒãˆ

    const packed = { pts, iw, ih };
    shapeCache.set(imgPath, packed);
    return packed;
  }

  // ===== ã‚²ãƒ¼ãƒ æœ¬ä½“ =====
  let spawning = false;

  window.onload = function () { init(); };

  function init() {
    engine = Engine.create();

    render = Render.create({
      element: document.body,
      engine: engine,
      options: {
        width: w,
        height: h,
        background: '#f0f0f0',
        wireframes: false,
        pixelRatio: 1
      }
    });

    createGround();

    Render.run(render);
    runner = Runner.create();
    Runner.run(runner, engine);

    Events.on(engine, 'beforeUpdate', updateLoop);

    window.addEventListener('resize', () => {
      w = window.innerWidth;
      h = window.innerHeight;
      render.canvas.width = w;
      render.canvas.height = h;
      createGround();
    });
  }

  function createGround() {
    if (ground) Composite.remove(engine.world, ground);

    const groundY = h - 180;
    const groundWidth = w * 0.3;

    ground = Bodies.rectangle(w / 2, groundY, groundWidth, 20, {
      isStatic: true,
      label: 'Ground',
      render: { fillStyle: '#8b4513' },
      friction: 1.0
    });
    Composite.add(engine.world, ground);
  }

  function startGame() {
    document.getElementById('title-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('controls').classList.remove('hidden');

    // ãƒ¯ãƒ¼ãƒ«ãƒ‰ã‚’ã‚¯ãƒªã‚¢ï¼ˆãŸã ã—ã‚¨ãƒ³ã‚¸ãƒ³/ãƒ¬ãƒ³ãƒ€ãƒ©ã¯ä½¿ã„å›ã™ï¼‰
    Composite.clear(engine.world, false);

    w = window.innerWidth; h = window.innerHeight;
    render.canvas.width = w; render.canvas.height = h;

    createGround();
    Render.lookAt(render, { min: { x: 0, y: 0 }, max: { x: w, y: h } });

    score = 0;
    document.getElementById('score-val').innerText = score;
    gameActive = true;

    spawnPintxo();
  }

  async function spawnPintxo() {
    if (!gameActive || spawning) return;
    spawning = true;

    try {
      const imgIndex = Math.floor(Math.random() * IMAGES.length);
      const imgPath = IMAGES[imgIndex];

      const spawnY = render.bounds.min.y + 100;
      const spawnX = w / 2;

      const info = await extractShapeFromAlpha(imgPath);

      // æŠ½å‡ºå¤±æ•—æ™‚ã®ä¿é™ºï¼ˆå…­è§’å½¢ï¼‰
      const fallback = {
        pts: [
          {x:-40,y:-40},{x:40,y:-40},{x:55,y:0},{x:40,y:40},{x:-40,y:40},{x:-55,y:0}
        ],
        iw: 100,
        ih: 100
      };

      const { pts, iw, ih } = info ?? fallback;

      // â˜…ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã¨ç‰©ç†ãƒœãƒ‡ã‚£ã®ã‚¹ã‚±ãƒ¼ãƒ«ã‚’ä¸€è‡´ã•ã›ã‚‹ï¼ˆã“ã“ãŒã‚ºãƒ¬ã®æ ¹æ²»ï¼‰
      const spriteScale = TARGET_SIZE / Math.max(iw, ih);

      currentPintxo = Bodies.fromVertices(spawnX, spawnY, [pts], {
        label: 'Pintxo',
        restitution: 0.1,
        friction: 0.8,
        render: {
          sprite: {
            texture: imgPath,
            xScale: spriteScale,
            yScale: spriteScale
          }
        }
      }, true);

      if (currentPintxo) {
        // ç‰©ç†ãƒœãƒ‡ã‚£ã‚‚åŒã˜å€ç‡ã§ç¸®å°ï¼ˆã•ã‚‰ã«å°‘ã—ã ã‘è‚‰æŠœãï¼‰
        Body.scale(currentPintxo, spriteScale * HIT_INSET, spriteScale * HIT_INSET);

        Body.setStatic(currentPintxo, true);
        currentPintxo.isDropped = false;
        Composite.add(engine.world, currentPintxo);
        isDropping = false;
      }
    } finally {
      spawning = false;
    }
  }

  function updateLoop() {
    if (!gameActive) return;

    const allBodies = Composite.allBodies(engine.world);

    // ã‚«ãƒ¡ãƒ©è¿½å¾“
    let highestY = ground.position.y;
    let hasStack = false;

    for (let b of allBodies) {
      if (b.label === 'Pintxo' && b !== currentPintxo) {
        if (b.position.y < highestY) { highestY = b.position.y; hasStack = true; }
      }
    }

    let targetTopY = 0;
    if (hasStack) targetTopY = highestY - (h * 0.5);
    if (targetTopY > 0) targetTopY = 0;

    const currentTopY = render.bounds.min.y;
    if (targetTopY < currentTopY) {
      const newY = currentTopY + (targetTopY - currentTopY) * 0.05;
      Render.lookAt(render, { min: { x: 0, y: newY }, max: { x: w, y: newY + h } });
    } else if (currentTopY < 0 && !hasStack) {
      Render.lookAt(render, { min: { x: 0, y: 0 }, max: { x: w, y: h } });
    }

    // ã€Œä¸‹ã«æ¶ˆãˆãŸã‚‰ãƒŸã‚¹ã€ã§OK
    const deadLine = render.bounds.max.y + 200;
    for (let b of allBodies) {
      if (b.label === 'Pintxo' && b !== currentPintxo) {
        if (b.position.y > deadLine) { gameOver(); break; }
      }
    }
  }

  function move(dir) {
    if (currentPintxo && !isDropping) Body.translate(currentPintxo, { x: dir * 6, y: 0 });
  }
  function rotate() {
    if (currentPintxo && !isDropping) Body.rotate(currentPintxo, Math.PI / 4);
  }
  function drop() {
    if (currentPintxo && !isDropping) {
      isDropping = true;
      Body.setStatic(currentPintxo, false);
      currentPintxo.isDropped = true;

      setTimeout(() => {
        if (gameActive) {
          calcScore(currentPintxo);
          spawnPintxo();
        }
      }, 800);
    }
  }

  function calcScore(body) {
    const diff = ground.position.y - body.position.y;
    if (diff > 0) {
      score += (Math.floor(diff / 10) + 10);
      document.getElementById('score-val').innerText = score;
    }
  }

  function gameOver() {
    if (!gameActive) return;
    gameActive = false;

    document.getElementById('final-score').innerText = score;
    document.getElementById('controls').classList.add('hidden');
    document.getElementById('game-over-screen').classList.remove('hidden');
    document.getElementById('input-area').classList.remove('hidden');
    document.getElementById('ranking-area').classList.add('hidden');
  }

  window.saveScore = function () {
    const name = document.getElementById('player-name').value || "åç„¡ã—";
    const data = JSON.parse(localStorage.getItem('pintxosRank')) || [];
    data.push({ name: name, score: score });
    data.sort((a, b) => b.score - a.score);
    localStorage.setItem('pintxosRank', JSON.stringify(data.slice(0, 5)));
    showRank();
  };

  function showRank() {
    const data = JSON.parse(localStorage.getItem('pintxosRank')) || [];
    const list = document.getElementById('ranking-list');
    list.innerHTML = "";
    data.forEach((d, i) => {
      list.innerHTML += `<li><span>${i + 1}.${d.name}</span><span>${d.score}</span></li>`;
    });
    document.getElementById('input-area').classList.add('hidden');
    document.getElementById('ranking-area').classList.remove('hidden');
  }

  window.resetGame = function () { startGame(); };

  // æ“ä½œãƒœã‚¿ãƒ³ï¼ˆé•·æŠ¼ã—å¯¾å¿œï¼‰
  const btnL = document.getElementById('btn-left');
  const btnR = document.getElementById('btn-right');
  const btnRot = document.getElementById('btn-rotate');
  const btnDrop = document.getElementById('btn-drop');

  const hold = (btn, action) => {
    let t;
    const s = (e) => { e.preventDefault(); action(); t = setInterval(action, 50); };
    const e2 = (e) => { e.preventDefault(); clearInterval(t); };
    btn.addEventListener('touchstart', s, { passive: false });
    btn.addEventListener('touchend', e2);
    btn.addEventListener('touchcancel', e2);
    btn.addEventListener('mousedown', s);
    btn.addEventListener('mouseup', e2);
    btn.addEventListener('mouseleave', e2);
  };

  hold(btnL, () => move(-1));
  hold(btnR, () => move(1));

  btnRot.addEventListener('click', rotate);
  btnRot.addEventListener('touchstart', (e) => { e.preventDefault(); rotate(); }, { passive: false });
  btnDrop.addEventListener('click', drop);
  btnDrop.addEventListener('touchstart', (e) => { e.preventDefault(); drop(); }, { passive: false });
</script>
</body>
</html>
