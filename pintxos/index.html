<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Pintxos Tower</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>

  <style>
    body { margin: 0; padding: 0; overflow: hidden; background-color: #f0f0f0; font-family: sans-serif; touch-action: none; }
    canvas { display: block; position: fixed; top: 0; left: 0; z-index: 0; }
    #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 10; }
    #score-board { position: absolute; top: 20px; left: 20px; font-size: 24px; font-weight: bold; color: #333; text-shadow: 2px 2px 0px white; }
    #controls { position: absolute; bottom: 30px; left: 0; width: 100%; height: 90px; display: flex; justify-content: center; align-items: center; gap: 20px; pointer-events: auto; }
    .control-btn { width: 60px; height: 60px; background: rgba(255,255,255,0.9); border: 2px solid #888; border-radius: 50%; font-size: 24px; cursor: pointer; display: flex; justify-content: center; align-items: center; box-shadow: 0 4px 5px rgba(0,0,0,0.2); user-select: none; -webkit-user-select: none; }
    .control-btn:active { background: #ccc; transform: translateY(2px); }
    #btn-drop { width: 80px; height: 80px; background: #ff4757; color: white; border: none; font-size: 32px; }
    .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255,255,255,0.95); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 20; pointer-events: auto; }
    .hidden { display: none !important; }
    button.primary-btn { padding: 15px 40px; font-size: 18px; background: #2ecc71; color: white; border: none; border-radius: 30px; margin-top: 15px; cursor: pointer; }
    #ranking-list { padding: 0; list-style: none; margin-top:10px; }
    #ranking-list li { margin: 5px 0; border-bottom: 1px solid #ddd; padding: 5px; width: 220px; display:flex; justify-content:space-between; }
  </style>
</head>
<body>

  <div id="ui-layer">
    <div id="score-board">SCORE: <span id="score-val">0</span></div>
    <div id="controls" class="hidden">
      <button class="control-btn" id="btn-left">â¬…ï¸</button>
      <button class="control-btn" id="btn-rotate">ğŸ”„</button>
      <button class="control-btn" id="btn-right">â¡ï¸</button>
      <button class="control-btn" id="btn-drop">â¬‡ï¸</button>
    </div>
  </div>

  <div id="title-screen" class="overlay">
    <h1>Pintxos Tower</h1>
    <p>ç”»åƒã‚’ç©ã¿ä¸Šã’ã‚ï¼</p>
    <button class="primary-btn" onclick="startGame()">START</button>
  </div>

  <div id="game-over-screen" class="overlay hidden">
    <h1>GAME OVER</h1>
    <p>Score: <span id="final-score">0</span></p>
    <div id="input-area">
      <input type="text" id="player-name" placeholder="åå‰ã‚’å…¥åŠ›" maxlength="8" style="padding:10px; font-size:16px; text-align:center;">
      <br>
      <button class="primary-btn" onclick="saveScore()">ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç™»éŒ²</button>
      <br>
      <button style="margin-top:15px; background:none; border:none; text-decoration:underline; color:#666;" onclick="resetGame()">ãƒªãƒˆãƒ©ã‚¤</button>
    </div>
    <div id="ranking-area" class="hidden">
      <h3>ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h3>
      <ul id="ranking-list"></ul>
      <button class="primary-btn" onclick="resetGame()">ã‚‚ã†ä¸€åº¦</button>
    </div>
  </div>

<script>
  // poly-decomp ã‚’ Matter.js ã® fromVertices ã§ä½¿ãˆã‚‹ã‚ˆã†ã«
  window.decomp = decomp;

  const Engine = Matter.Engine,
        Render = Matter.Render,
        Runner = Matter.Runner,
        Bodies = Matter.Bodies,
        Composite = Matter.Composite,
        Events = Matter.Events,
        Body = Matter.Body;

  let engine, render, runner;
  let ground;
  let currentPintxo = null;
  let isDropping = false;
  let gameActive = false;
  let score = 0;

  const IMAGES = [];
  for(let i=1; i<=11; i++) IMAGES.push(`./img/${i}.png`);

  let w = window.innerWidth;
  let h = window.innerHeight;

  // ====== é€éPNG(ã‚¢ãƒ«ãƒ•ã‚¡) â†’ è¼ªéƒ­ãƒãƒªã‚´ãƒ³æŠ½å‡ºï¼ˆBæ–¹å¼ï¼‰ ======
  const shapeCache = new Map();

  function loadImage(src){
    return new Promise((resolve, reject)=>{
      const img = new Image();
      img.onload = ()=>resolve(img);
      img.onerror = (e)=>reject(e);
      img.src = src;
    });
  }

  function polygonArea(pts){
    let a=0;
    for(let i=0;i<pts.length;i++){
      const p=pts[i], q=pts[(i+1)%pts.length];
      a += (p.x*q.y - q.x*p.y);
    }
    return a/2;
  }

  // Moore neighbor tracing ã§å¤–å‘¨è¼ªéƒ­ã‚’1æœ¬æŠ½å‡ºï¼ˆç©´ã¯ç„¡è¦–ï¼‰
  function traceMoore(boundary, w, h, sx, sy){
    const dirs = [
      {x:1,y:0},{x:1,y:1},{x:0,y:1},{x:-1,y:1},
      {x:-1,y:0},{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1}
    ];
    let x=sx, y=sy;
    let bx=sx-1, by=sy;         // backtrack
    const startX=x, startY=y;
    const out=[];
    const safety = w*h*8;
    let steps=0;

    const dirIndex = (dx,dy)=>{
      for(let i=0;i<dirs.length;i++) if(dirs[i].x===dx && dirs[i].y===dy) return i;
      return 0;
    };

    do{
      out.push({x,y});
      let bi = dirIndex(x-bx, y-by);
      let found=false;
      for(let k=0;k<8;k++){
        const idx = (bi+1+k)%8;
        const nx=x+dirs[idx].x, ny=y+dirs[idx].y;
        if(nx<0||nx>=w||ny<0||ny>=h) continue;
        if(boundary[ny*w+nx]){
          const pb=(idx+7)%8;
          bx=x+dirs[pb].x; by=y+dirs[pb].y;
          x=nx; y=ny;
          found=true;
          break;
        }
      }
      if(!found) break;
      steps++;
      if(steps>safety) break;
    }while(!(x===startX && y===startY));

    return out;
  }

  // RDP ç°¡æ˜“ï¼ˆé ‚ç‚¹ã‚’æ¸›ã‚‰ã™ï¼‰
  function rdpSimplify(points, eps){
    if(points.length<3) return points;

    const sq = (x)=>x*x;
    const dist2 = (p,a,b)=>{
      const vx=b.x-a.x, vy=b.y-a.y;
      const wx=p.x-a.x, wy=p.y-a.y;
      const c1 = vx*wx + vy*wy;
      if (c1<=0) return sq(p.x-a.x)+sq(p.y-a.y);
      const c2 = vx*vx+vy*vy;
      if (c2<=c1) return sq(p.x-b.x)+sq(p.y-b.y);
      const t=c1/c2;
      const px=a.x+t*vx, py=a.y+t*vy;
      return sq(p.x-px)+sq(p.y-py);
    };
    const eps2=eps*eps;

    function rec(pts){
      let maxD=0, idx=-1;
      const a=pts[0], b=pts[pts.length-1];
      for(let i=1;i<pts.length-1;i++){
        const d=dist2(pts[i],a,b);
        if(d>maxD){ maxD=d; idx=i; }
      }
      if(maxD>eps2){
        const left=rec(pts.slice(0,idx+1));
        const right=rec(pts.slice(idx));
        return left.slice(0,-1).concat(right);
      }
      return [a,b];
    }
    return rec(points);
  }

  function capVertices(pts, maxV){
    if(pts.length<=maxV) return pts;
    const step = pts.length / maxV;
    const out=[];
    for(let i=0;i<maxV;i++) out.push(pts[Math.floor(i*step)]);
    return out;
  }

  // PNGã‚¢ãƒ«ãƒ•ã‚¡ã‹ã‚‰å¤–å‘¨è¼ªéƒ­ã‚’æŠ½å‡ºã—ã€ä¸­å¿ƒåŸºæº–ã®ãƒ­ãƒ¼ã‚«ãƒ«é ‚ç‚¹ã«ã—ã¦è¿”ã™
  async function verticesFromAlpha(imgPath, opt={}){
    if (shapeCache.has(imgPath)) return shapeCache.get(imgPath);

    const threshold = opt.threshold ?? 18;        // åŠé€æ˜ç¸ã‚’ç„¡è¦–ã™ã‚‹ãªã‚‰ä¸Šã’ã‚‹(ä¾‹:25-40)
    const sampleScale = opt.sampleScale ?? 0.25;  // ç²¾å¯†ã«ã—ãŸã„ãªã‚‰0.3ã€œ0.4
    const simplifyEps = opt.simplifyEps ?? 2.8;   // å¤§ãã„ã»ã©é ‚ç‚¹æ¸›ã£ã¦è»½ã„
    const maxVertices = opt.maxVertices ?? 90;    // ç²¾å¯†ã«ã—ãŸã„ãªã‚‰120

    const img = await loadImage(imgPath);

    const w0 = Math.max(16, Math.floor(img.naturalWidth  * sampleScale));
    const h0 = Math.max(16, Math.floor(img.naturalHeight * sampleScale));

    const cvs = document.createElement("canvas");
    cvs.width = w0; cvs.height = h0;
    const ctx = cvs.getContext("2d", { willReadFrequently:true });
    ctx.clearRect(0,0,w0,h0);
    ctx.drawImage(img, 0,0,w0,h0);

    const data = ctx.getImageData(0,0,w0,h0).data;
    const mask = new Uint8Array(w0*h0);
    let solid=0;

    for(let y=0;y<h0;y++){
      for(let x=0;x<w0;x++){
        const i = (y*w0 + x)*4;
        const a = data[i+3];
        if (a > threshold){
          mask[y*w0 + x] = 1;
          solid++;
        }
      }
    }
    if (solid < 30) return null;

    const boundary = new Uint8Array(w0*h0);
    let sx=-1, sy=-1;
    for(let y=1;y<h0-1;y++){
      for(let x=1;x<w0-1;x++){
        const idx = y*w0+x;
        if(!mask[idx]) continue;
        if(!mask[idx-1] || !mask[idx+1] || !mask[idx-w0] || !mask[idx+w0]){
          boundary[idx]=1;
          if(sy===-1 || y<sy || (y===sy && x<sx)){ sx=x; sy=y; }
        }
      }
    }
    if (sx===-1) return null;

    const contour = traceMoore(boundary, w0, h0, sx, sy);
    if(!contour || contour.length < 20) return null;

    const inv = 1/sampleScale;
    const cx = w0/2, cy = h0/2;
    let pts = contour.map(p => ({ x:(p.x - cx)*inv, y:(p.y - cy)*inv }));

    pts = rdpSimplify(pts, simplifyEps*inv);
    pts = capVertices(pts, maxVertices);

    if (pts.length < 8) return null;

    // Matter.jsã¯ã ã„ãŸã„CWã®æ–¹ãŒå®‰å®šã—ãŒã¡ãªã®ã§æƒãˆã‚‹
    if (polygonArea(pts) > 0) pts.reverse();

    shapeCache.set(imgPath, pts);
    return pts;
  }

  window.onload = function() { init(); };

  function init() {
    engine = Engine.create();

    render = Render.create({
      element: document.body,
      engine: engine,
      options: {
        width: w,
        height: h,
        background: '#f0f0f0',
        wireframes: false,
        pixelRatio: 1
      }
    });

    createGround();
    Render.run(render);
    runner = Runner.create();
    Runner.run(runner, engine);

    Events.on(engine, 'beforeUpdate', updateLoop);

    window.addEventListener('resize', () => {
      w = window.innerWidth; h = window.innerHeight;
      render.canvas.width = w;
      render.canvas.height = h;
      createGround();
    });
  }

  // åœŸå°
  function createGround() {
    if(ground) Composite.remove(engine.world, ground);

    const groundY = h - 180;
    const groundWidth = w * 0.3;

    ground = Bodies.rectangle(w/2, groundY, groundWidth, 20, {
      isStatic: true,
      label: 'Ground',
      render: { fillStyle: '#8b4513' },
      friction: 1.0
    });
    Composite.add(engine.world, ground);
  }

  function startGame() {
    document.getElementById('title-screen').classList.add('hidden');
    document.getElementById('game-over-screen').classList.add('hidden');
    document.getElementById('controls').classList.remove('hidden');

    Composite.clear(engine.world, false);
    Engine.clear(engine);

    w = window.innerWidth; h = window.innerHeight;
    render.canvas.width = w; render.canvas.height = h;

    createGround();
    Render.lookAt(render, { min: { x: 0, y: 0 }, max: { x: w, y: h } });

    score = 0;
    document.getElementById('score-val').innerText = score;
    gameActive = true;

    spawnPintxo(); // asyncã ã‘ã©å‘¼ã³ã£ã±ãªã—ã§OKï¼ˆå†…éƒ¨ã§awaitã—ã¦ã‹ã‚‰å‡ºç¾ï¼‰
  }

  // â˜…ã“ã“ãŒå¤‰æ›´ç‚¹ï¼šé€éPNGã®ã‚¢ãƒ«ãƒ•ã‚¡ã‹ã‚‰è‡ªå‹•ã§å½“ãŸã‚Šåˆ¤å®šãƒãƒªã‚´ãƒ³ã‚’ä½œã‚‹
  async function spawnPintxo() {
    if (!gameActive) return;

    const imgIndex = Math.floor(Math.random() * IMAGES.length);
    const imgPath = IMAGES[imgIndex];

    const spawnY = render.bounds.min.y + 100;
    const spawnX = w / 2;

    // é€éç¸ãŒå¤šã„/åŠé€æ˜ãŒå¤šã„ãªã‚‰ threshold ã‚’ä¸Šã’ã‚‹ï¼ˆä¾‹: 25ã€œ40ï¼‰
    const verts = await verticesFromAlpha(imgPath, {
      threshold: 18,
      sampleScale: 0.25,
      simplifyEps: 2.8,
      maxVertices: 90
    });

    // æŠ½å‡ºå¤±æ•—æ™‚ã®ä¿é™ºï¼ˆå…­è§’å½¢ï¼‰
    const fallback = [
      {x:-40,y:-40},{x:40,y:-40},{x:55,y:0},{x:40,y:40},{x:-40,y:40},{x:-55,y:0}
    ];

    const shape = verts ?? fallback;

    currentPintxo = Bodies.fromVertices(spawnX, spawnY, [shape], {
      label: 'Pintxo',
      restitution: 0.1,
      friction: 0.8,
      render: {
        sprite: {
          texture: imgPath,
          xScale: 0.8,
          yScale: 0.8
        }
      }
    }, true);

    if(currentPintxo) {
      // ã€Œæµ®ã„ã¦è¦‹ãˆã‚‹ã€ãªã‚‰å½“ãŸã‚Šåˆ¤å®šã ã‘å°‘ã—å°ã•ãã™ã‚‹ï¼ˆé€æ˜ãƒ•ãƒãŒå¤šã„ç”»åƒå‘ã‘ï¼‰
      // å€¤ã‚’ä¸‹ã’ã‚‹ã»ã©â€œè‚‰æŠœãâ€ãŒå¼·ããªã‚‹
      Body.scale(currentPintxo, 0.95, 0.95);

      Body.setStatic(currentPintxo, true);
      currentPintxo.isDropped = false;
      Composite.add(engine.world, currentPintxo);
      isDropping = false;
    }
  }

  function updateLoop() {
    if (!gameActive) return;

    let allBodies = Composite.allBodies(engine.world);
    let highestY = ground.position.y;
    let hasStack = false;

    for(let b of allBodies) {
      if(b.label === 'Pintxo' && b !== currentPintxo) {
        if(b.position.y < highestY) {
          highestY = b.position.y;
          hasStack = true;
        }
      }
    }

    let targetTopY = 0;
    if (hasStack) targetTopY = highestY - (h * 0.5);
    if (targetTopY > 0) targetTopY = 0;

    const currentTopY = render.bounds.min.y;
    if (targetTopY < currentTopY) {
      const newY = currentTopY + (targetTopY - currentTopY) * 0.05;
      Render.lookAt(render, { min: { x: 0, y: newY }, max: { x: w, y: newY + h } });
    } else if (currentTopY < 0 && !hasStack) {
      Render.lookAt(render, { min: { x: 0, y: 0 }, max: { x: w, y: h } });
    }

    // ã€Œä¸‹ã«æ¶ˆãˆãŸã‚‰ãƒŸã‚¹ã€ã§OKï¼šç”»é¢å¤–ï¼ˆä¸‹ï¼‰ã«è½ã¡ãŸã‚‰ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
    const deadLine = render.bounds.max.y + 200;
    allBodies.forEach(b => {
      if (b.label === 'Pintxo' && b !== currentPintxo) {
        if (b.position.y > deadLine) gameOver();
      }
    });
  }

  function move(dir) {
    if(currentPintxo && !isDropping) Body.translate(currentPintxo, {x: dir*6, y:0});
  }
  function rotate() {
    if(currentPintxo && !isDropping) Body.rotate(currentPintxo, Math.PI/4);
  }
  function drop() {
    if(currentPintxo && !isDropping) {
      isDropping = true;
      Body.setStatic(currentPintxo, false);
      currentPintxo.isDropped = true;
      setTimeout(() => {
        if(gameActive) {
          calcScore(currentPintxo);
          spawnPintxo();
        }
      }, 800); // 2ç§’ã¯é•·ã„ã®ã§çŸ­ç¸®ï¼ˆå¥½ã¿ã§æˆ»ã—ã¦OKï¼‰
    }
  }

  function calcScore(body) {
    const diff = ground.position.y - body.position.y;
    if (diff > 0) {
      score += (Math.floor(diff / 10) + 10);
      document.getElementById('score-val').innerText = score;
    }
  }

  function gameOver() {
    if (!gameActive) return;
    gameActive = false;
    document.getElementById('final-score').innerText = score;
    document.getElementById('controls').classList.add('hidden');
    document.getElementById('game-over-screen').classList.remove('hidden');
    document.getElementById('input-area').classList.remove('hidden');
    document.getElementById('ranking-area').classList.add('hidden');
  }

  window.saveScore = function() {
    const name = document.getElementById('player-name').value || "åç„¡ã—";
    const data = JSON.parse(localStorage.getItem('pintxosRank')) || [];
    data.push({ name: name, score: score });
    data.sort((a,b)=>b.score-a.score);
    localStorage.setItem('pintxosRank', JSON.stringify(data.slice(0,5)));
    showRank();
  };

  function showRank() {
    const data = JSON.parse(localStorage.getItem('pintxosRank')) || [];
    const list = document.getElementById('ranking-list');
    list.innerHTML = "";
    data.forEach((d,i) => {
      list.innerHTML += `<li><span>${i+1}.${d.name}</span><span>${d.score}</span></li>`;
    });
    document.getElementById('input-area').classList.add('hidden');
    document.getElementById('ranking-area').classList.remove('hidden');
  }

  window.resetGame = function() { startGame(); };

  const btnL = document.getElementById('btn-left');
  const btnR = document.getElementById('btn-right');
  const btnRot = document.getElementById('btn-rotate');
  const btnDrop = document.getElementById('btn-drop');

  const hold = (btn, action) => {
    let t;
    const s = (e)=>{ e.preventDefault(); action(); t=setInterval(action,50); };
    const e2 = (e)=>{ e.preventDefault(); clearInterval(t); };
    btn.addEventListener('touchstart', s, {passive:false});
    btn.addEventListener('touchend', e2);
    btn.addEventListener('touchcancel', e2);
    btn.addEventListener('mousedown', s);
    btn.addEventListener('mouseup', e2);
    btn.addEventListener('mouseleave', e2);
  };

  hold(btnL, ()=>move(-1));
  hold(btnR, ()=>move(1));

  btnRot.addEventListener('click', rotate);
  btnRot.addEventListener('touchstart', (e)=>{e.preventDefault(); rotate()},{passive:false});
  btnDrop.addEventListener('click', drop);
  btnDrop.addEventListener('touchstart', (e)=>{e.preventDefault(); drop()},{passive:false});
</script>

</body>
</html>
