<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Pintxos Tower</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>

  <style>
    body { margin:0; padding:0; overflow:hidden; background:#f2f2f2; font-family: system-ui, -apple-system, sans-serif; touch-action:none; }
    canvas { display:block; position:fixed; top:0; left:0; }
    #ui-layer { position:absolute; inset:0; pointer-events:none; z-index:10; }
    #score-board { position:absolute; top:20px; left:20px; font-size:44px; font-weight:800; color:#333; text-shadow: 2px 2px 0 #fff; }
    #controls { position:absolute; bottom:30px; left:0; width:100%; height:110px; display:flex; justify-content:center; align-items:center; gap:22px; pointer-events:auto; }
    .control-btn { width:72px; height:72px; background:rgba(255,255,255,0.92); border:2px solid #888; border-radius:50%; font-size:28px; cursor:pointer;
      display:flex; justify-content:center; align-items:center; box-shadow:0 6px 10px rgba(0,0,0,0.18); user-select:none; -webkit-user-select:none; }
    .control-btn:active { transform: translateY(2px); filter:brightness(0.95); }
    #btn-drop { width:92px; height:92px; background:#ff4757; color:#fff; border:none; font-size:34px; }
    .overlay { position:absolute; inset:0; background:rgba(255,255,255,0.95); display:flex; flex-direction:column; justify-content:center; align-items:center; z-index:20; pointer-events:auto; }
    .hidden { display:none !important; }
    button.primary-btn { padding:14px 40px; font-size:18px; background:#2ecc71; color:#fff; border:none; border-radius:30px; margin-top:15px; cursor:pointer; }
    #ranking-list { padding:0; list-style:none; margin-top:10px; }
    #ranking-list li { margin:6px 0; border-bottom:1px solid #ddd; padding:6px; width:240px; display:flex; justify-content:space-between; }

    /* debug */
    #debugBtn {
      position:absolute; top:18px; right:18px; z-index:30; pointer-events:auto;
      background:#222; color:#fff; border:none; padding:10px 14px; border-radius:999px;
      box-shadow:0 10px 18px rgba(0,0,0,0.22); cursor:pointer; font-weight:700;
    }
    #debugLayer {
      position:fixed; top:0; left:0; z-index:9; pointer-events:none; display:none;
    }
  </style>
</head>
<body>

  <canvas id="debugLayer"></canvas>

  <div id="ui-layer">
    <div id="score-board">SCORE: <span id="score-val">0</span></div>

    <div id="controls" class="hidden">
      <button class="control-btn" id="btn-left">‚¨ÖÔ∏è</button>
      <button class="control-btn" id="btn-rotate">üîÑ</button>
      <button class="control-btn" id="btn-right">‚û°Ô∏è</button>
      <button class="control-btn" id="btn-drop">‚¨áÔ∏è</button>
    </div>
  </div>

  <button id="debugBtn">üêû DEBUG</button>

  <div id="title-screen" class="overlay">
    <h1 style="margin:0 0 6px 0;">Pintxos Tower</h1>
    <p style="margin:0 0 12px 0;">Á©ç„Åø‰∏ä„Åí„Çç„ÄÇËêΩ„Å®„Åó„Åü„ÇâË≤†„Åë„ÄÇ</p>
    <button class="primary-btn" id="startBtn">START</button>
  </div>

  <div id="game-over-screen" class="overlay hidden">
    <h1>GAME OVER</h1>
    <p>Score: <span id="final-score">0</span></p>
    <div id="input-area">
      <input type="text" id="player-name" placeholder="ÂêçÂâç„ÇíÂÖ•Âäõ" maxlength="8" style="padding:10px; font-size:16px; text-align:center;">
      <br>
      <button class="primary-btn" id="saveBtn">„É©„É≥„Ç≠„É≥„Ç∞ÁôªÈå≤</button>
      <br>
      <button style="margin-top:15px; background:none; border:none; text-decoration:underline; color:#666;" id="retryBtn">„É™„Éà„É©„Ç§</button>
    </div>
    <div id="ranking-area" class="hidden">
      <h3>„É©„É≥„Ç≠„É≥„Ç∞</h3>
      <ul id="ranking-list"></ul>
      <button class="primary-btn" id="againBtn">„ÇÇ„ÅÜ‰∏ÄÂ∫¶</button>
    </div>
  </div>

  <!-- shape-extract.js „ÇíÂêå„Éï„Ç©„É´„ÉÄ„Å´ÁΩÆ„Åè -->
  <script src="shape-extract.js"></script>

  <script>
    const { Engine, Render, Runner, Bodies, Composite, Events, Body } = Matter;

    let engine, render, runner;
    let ground;
    let current = null;
    let isDropping = false;
    let gameActive = false;
    let score = 0;

    let W = window.innerWidth;
    let H = window.innerHeight;

    const IMG_COUNT = 11;
    const TEX = i => `img/${i}.png`;
    const MASK = i => `mask/${i}.png`;

    let assets = [];
    let debug = false;

    const debugCanvas = document.getElementById('debugLayer');
    const debugCtx = debugCanvas.getContext('2d');

    function resizeAll() {
      W = window.innerWidth; H = window.innerHeight;
      render.canvas.width = W; render.canvas.height = H;
      debugCanvas.width = W; debugCanvas.height = H;
      createGround();
    }

    function worldToScreen(x, y) {
      const b = render.bounds;
      const sx = (x - b.min.x) * (W / (b.max.x - b.min.x));
      const sy = (y - b.min.y) * (H / (b.max.y - b.min.y));
      return { x: sx, y: sy };
    }

    function drawDebug() {
      if (!debug) return;
      debugCtx.clearRect(0, 0, W, H);

      const bodies = Composite.allBodies(engine.world);
      debugCtx.lineWidth = 2;
      debugCtx.strokeStyle = "#00ff6a";

      for (const b of bodies) {
        if (b.label !== "Pintxo") continue;
        const vs = b.vertices;
        if (!vs || vs.length < 3) continue;

        debugCtx.beginPath();
        const p0 = worldToScreen(vs[0].x, vs[0].y);
        debugCtx.moveTo(p0.x, p0.y);
        for (let i = 1; i < vs.length; i++) {
          const p = worldToScreen(vs[i].x, vs[i].y);
          debugCtx.lineTo(p.x, p.y);
        }
        debugCtx.closePath();
        debugCtx.stroke();
      }
    }

    function init() {
      engine = Engine.create({ enableSleeping: true });
      engine.positionIterations = 12;
      engine.velocityIterations = 8;

      render = Render.create({
        element: document.body,
        engine,
        options: {
          width: W,
          height: H,
          background: "#f2f2f2",
          wireframes: false,
          pixelRatio: 1
        }
      });

      Render.run(render);
      runner = Runner.create();
      Runner.run(runner, engine);

      createGround();

      Events.on(engine, "beforeUpdate", updateLoop);
      Events.on(render, "afterRender", () => drawDebug());

      window.addEventListener("resize", resizeAll);
    }

    function createGround() {
      if (ground) Composite.remove(engine.world, ground);

      const y = H - 180;
      const w = W * 0.55;      // „Å°„Çá„ÅÑÂ∫É„ÇÅÔºàÈÅä„Å≥„ÇÑ„Åô„ÅÑÔºâ
      const h = 22;

      ground = Bodies.rectangle(W / 2, y, w, h, {
        isStatic: true,
        label: "Ground",
        friction: 1.0,
        render: { fillStyle: "#8b4513" }
      });

      Composite.add(engine.world, ground);
    }

    async function loadAssets() {
      assets = [];
      for (let i = 1; i <= IMG_COUNT; i++) {
        const a = await ShapeExtract.prepare({
          textureUrl: TEX(i),
          maskUrl: MASK(i),
          targetMax: 150,   // ‚Üê„Çµ„Ç§„Ç∫ÊÑü„ÅØ„Åì„Åì
          alphaThr: 10,     // ‚Üê„Éû„Çπ„ÇØ„ÅåÁôΩ/ÈÄèÊòé„Å™„Çâ10„ÅßOK
          hitInset: 0.97,   // ‚ÜêÈöôÈñì„ÅåÊ∞ó„Å´„Å™„Çã„Å™„Çâ0.95„Äú0.98
          maxVerts: 72
        });
        assets.push(a);
      }
    }

    function resetWorldKeepRender() {
      Composite.clear(engine.world, false);
      Engine.clear(engine);

      createGround();
      Render.lookAt(render, { min: { x: 0, y: 0 }, max: { x: W, y: H } });

      score = 0;
      document.getElementById("score-val").innerText = score;
      isDropping = false;
      current = null;
    }

    function startGame() {
      document.getElementById("title-screen").classList.add("hidden");
      document.getElementById("game-over-screen").classList.add("hidden");
      document.getElementById("controls").classList.remove("hidden");

      gameActive = true;
      resetWorldKeepRender();
      spawn();
    }

    function spawn() {
      if (!gameActive) return;
      const asset = assets[Math.floor(Math.random() * assets.length)];

      const spawnX = W / 2;
      const spawnY = render.bounds.min.y + 140;

      current = ShapeExtract.createBody(asset, spawnX, spawnY, { isStatic: true });
      current._asset = asset;
      current._scored = false;

      Composite.add(engine.world, current);
      isDropping = false;
    }

    function move(dir) {
      if (!current || isDropping) return;
      Body.translate(current, { x: dir * 8, y: 0 });
    }

    function rotate() {
      if (!current || isDropping) return;
      Body.rotate(current, Math.PI / 6);
    }

    function drop() {
      if (!current || isDropping) return;
      isDropping = true;
      Body.setStatic(current, false);
      current._droppedAt = performance.now();
    }

    function addScore(body) {
      if (!body || body._scored) return;
      body._scored = true;

      const diff = ground.position.y - body.position.y;
      if (diff > 0) {
        score += (Math.floor(diff / 10) + 10);
        document.getElementById("score-val").innerText = score;
      }
    }

    function gameOver() {
      gameActive = false;
      document.getElementById("final-score").innerText = score;
      document.getElementById("controls").classList.add("hidden");
      document.getElementById("game-over-screen").classList.remove("hidden");
      document.getElementById("input-area").classList.remove("hidden");
      document.getElementById("ranking-area").classList.add("hidden");
    }

    function updateCamera() {
      const bodies = Composite.allBodies(engine.world);
      let highest = ground.position.y;
      let hasStack = false;

      for (const b of bodies) {
        if (b.label === "Pintxo") {
          highest = Math.min(highest, b.position.y);
          hasStack = true;
        }
      }

      let targetTopY = 0;
      if (hasStack) targetTopY = highest - (H * 0.55);
      if (targetTopY > 0) targetTopY = 0;

      const curTopY = render.bounds.min.y;
      if (targetTopY < curTopY) {
        const newY = curTopY + (targetTopY - curTopY) * 0.06;
        Render.lookAt(render, { min: { x: 0, y: newY }, max: { x: W, y: newY + H } });
      }
    }

    function updateLoop() {
      if (!gameActive) return;

      updateCamera();

      // ‰∏ã„Å´Ê∂à„Åà„Åü„Çâ„Éü„ÇπÔºàÔºùËêΩ‰∏ãË≤†„ÅëÔºâ
      const bodies = Composite.allBodies(engine.world);
      const deadLine = ground.position.y + H * 0.9;
      for (const b of bodies) {
        if (b.label === "Pintxo") {
          if (b.position.y > deadLine) {
            gameOver();
            return;
          }
        }
      }

      // dropÂæåÔºöËêΩ„Å°ÁùÄ„ÅÑ„Åü„ÇâÊé°ÁÇπ„Åó„Å¶Ê¨°„ÇíÂá∫„Åô
      if (isDropping && current) {
        const now = performance.now();
        const elapsed = now - (current._droppedAt || now);

        const settled = current.isSleeping || (current.speed < 0.08 && Math.abs(current.angularSpeed) < 0.06);
        const enoughTime = elapsed > 1200; // ÊúÄ‰Ωé„Å°„Çá„ÅÑÂæÖ„Å§

        if (settled && enoughTime) {
          addScore(current);
          spawn();
        }
      }
    }

    // ===== Ranking =====
    function saveScore() {
      const name = document.getElementById("player-name").value || "ÂêçÁÑ°„Åó";
      const data = JSON.parse(localStorage.getItem("pintxosRank") || "[]");
      data.push({ name, score });
      data.sort((a,b) => b.score - a.score);
      localStorage.setItem("pintxosRank", JSON.stringify(data.slice(0, 5)));
      showRank();
    }
    function showRank() {
      const data = JSON.parse(localStorage.getItem("pintxosRank") || "[]");
      const list = document.getElementById("ranking-list");
      list.innerHTML = "";
      data.forEach((d,i) => {
        const li = document.createElement("li");
        li.innerHTML = `<span>${i+1}. ${d.name}</span><span>${d.score}</span>`;
        list.appendChild(li);
      });
      document.getElementById("input-area").classList.add("hidden");
      document.getElementById("ranking-area").classList.remove("hidden");
    }

    // ===== Controls (hold) =====
    function hold(btn, action) {
      let t = null;
      const start = (e) => { e.preventDefault(); action(); t = setInterval(action, 55); };
      const end = (e) => { e.preventDefault(); if (t) clearInterval(t); t = null; };
      btn.addEventListener("touchstart", start, { passive:false });
      btn.addEventListener("touchend", end);
      btn.addEventListener("mousedown", start);
      btn.addEventListener("mouseup", end);
      btn.addEventListener("mouseleave", end);
    }

    // ===== Boot =====
    window.addEventListener("load", async () => {
      init();

      document.getElementById("startBtn").onclick = async () => {
        // assets„ÅåÊú™„É≠„Éº„Éâ„Å™„ÇâÂÖà„Å´Ë™≠„ÇÄ
        if (assets.length === 0) {
          document.getElementById("startBtn").disabled = true;
          document.getElementById("startBtn").textContent = "LOADING...";
          await loadAssets();
          document.getElementById("startBtn").disabled = false;
          document.getElementById("startBtn").textContent = "START";
        }
        startGame();
      };

      document.getElementById("saveBtn").onclick = saveScore;
      document.getElementById("retryBtn").onclick = () => startGame();
      document.getElementById("againBtn").onclick = () => startGame();

      const btnL = document.getElementById("btn-left");
      const btnR = document.getElementById("btn-right");
      const btnRot = document.getElementById("btn-rotate");
      const btnDrop = document.getElementById("btn-drop");

      hold(btnL, () => move(-1));
      hold(btnR, () => move( 1));

      btnRot.addEventListener("click", rotate);
      btnRot.addEventListener("touchstart", e => { e.preventDefault(); rotate(); }, { passive:false });

      btnDrop.addEventListener("click", drop);
      btnDrop.addEventListener("touchstart", e => { e.preventDefault(); drop(); }, { passive:false });

      document.getElementById("debugBtn").onclick = () => {
        debug = !debug;
        debugCanvas.style.display = debug ? "block" : "none";
      };

      // debug canvas„Çµ„Ç§„Ç∫Âêà„Çè„Åõ
      debugCanvas.width = W; debugCanvas.height = H;
    });
  </script>
</body>
</html>
