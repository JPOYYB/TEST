<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
  <title>„Çø„ÉØ„Éº„Éê„Éà„É´ÔºàDebugÔºâ</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <script src="./shape-extract.js"></script>
„ÄÄ<script src="shape-extract.js?v=7"></script>

  <style>
    body{margin:0;overflow:hidden;background:#f3f3f3;font-family:system-ui,-apple-system,sans-serif;touch-action:none}
    canvas{position:fixed;inset:0}
    #ui{position:absolute;inset:0;pointer-events:none}
    #score{position:absolute;top:18px;left:18px;font-weight:900;font-size:44px;color:#222;text-shadow:2px 2px 0 #fff}
    #controls{position:absolute;left:0;right:0;bottom:28px;height:110px;display:flex;justify-content:center;align-items:center;gap:22px;pointer-events:auto}
    .btn{width:86px;height:86px;border-radius:50%;background:rgba(255,255,255,.95);border:4px solid rgba(0,0,0,.25);
      box-shadow:0 10px 18px rgba(0,0,0,.18);font-size:34px;display:flex;justify-content:center;align-items:center;user-select:none}
    .btn:active{transform:translateY(2px);filter:brightness(.95)}
    #drop{width:110px;height:110px;border-radius:50%;background:#ff4d5a;color:#fff;border:none;font-size:40px}
    #dbgBtn{position:absolute;top:16px;right:16px;z-index:30;pointer-events:auto;background:#111;color:#fff;border:none;border-radius:999px;
      padding:10px 14px;font-size:16px;opacity:.85}
    #dbgPanel{position:absolute;top:62px;right:16px;z-index:30;pointer-events:none;background:rgba(0,0,0,.72);color:#fff;
      padding:10px 12px;border-radius:12px;font-size:12px;max-width:280px;line-height:1.35}
    .hidden{display:none!important}
  </style>
</head>
<body>
  <div id="ui">
    <div id="score">SCORE: <span id="sv">0</span></div>
    <button id="dbgBtn">üêû DEBUG</button>
    <div id="dbgPanel" class="hidden"></div>

    <div id="controls">
      <div class="btn" id="L">‚¨ÖÔ∏è</div>
      <div class="btn" id="Rot">üîÑ</div>
      <div class="btn" id="R">‚û°Ô∏è</div>
      <button id="drop">‚¨áÔ∏è</button>
    </div>
  </div>

<script>
(() => {
  const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner;
  const Bodies = Matter.Bodies, Composite = Matter.Composite, Events = Matter.Events, Body = Matter.Body;

  // ===== Ë®≠ÂÆö =====
  const CFG = {
    count: 11,
    texDir: "./img/",
    maskDir: "./mask/",
    targetSize: 150,
    hitInset: 0.97,                 // Ë©∞„ÇÅ„Åü„ÅÑ„Å™„Çâ 0.95„Äú0.99
    shape: { threshold: 5, sampleScale: 0.6, nPoints: 180 },  // „Éá„Éê„ÉÉ„Ç∞Áî®„Å´„ÇÑ„ÇÑÈ´òÁ≤æÂ∫¶
    ground: { yPad: 190, wRatio: 0.38, h: 22 },
    moveStep: 7,
    rotateStep: Math.PI / 6,
    deadPad: 1.35,
    settleMaxMs: 2200
  };

  const IMAGES = Array.from({length: CFG.count}, (_,i)=> `${CFG.texDir}${i+1}.png`);
  const MASKS  = Array.from({length: CFG.count}, (_,i)=> `${CFG.maskDir}${i+1}.png`);

  let engine, render, runner;
  let w = innerWidth, h = innerHeight;
  let ground = null;
  let current = null;
  let isDropping = false;
  let active = true;
  let score = 0;

  // debug
  let debugOn = true;
  const dbgBtn = document.getElementById("dbgBtn");
  const dbgPanel = document.getElementById("dbgPanel");
  dbgBtn.addEventListener("click", () => {
    debugOn = !debugOn;
    dbgPanel.classList.toggle("hidden", !debugOn);
    ShapeExtract.setDebug(debugOn);
  });
  dbgPanel.classList.toggle("hidden", !debugOn);

  window.addEventListener("load", init);

  function init() {
    try { Matter.Common.setDecomp(decomp); } catch (_) {}

    engine = Engine.create();
    render = Render.create({
      element: document.body,
      engine,
      options: { width:w, height:h, wireframes:false, background:"#f3f3f3", pixelRatio:1 }
    });
    Render.run(render);
    runner = Runner.create();
    Runner.run(runner, engine);

    createGround();
    Events.on(engine, "beforeUpdate", tick);
    Events.on(render, "afterRender", drawDebug);

    window.addEventListener("resize", () => {
      w = innerWidth; h = innerHeight;
      render.canvas.width = w; render.canvas.height = h;
    });

    bindControls();
    spawn(); // ÈñãÂßãÊôÇ„Å´1ÂÄãÂá∫„Åô
  }

  function createGround() {
    if (ground) Composite.remove(engine.world, ground);
    const gy = h - CFG.ground.yPad;
    const gw = w * CFG.ground.wRatio;
    ground = Bodies.rectangle(w/2, gy, gw, CFG.ground.h, {
      isStatic:true, label:"Ground", friction:1.0, render:{fillStyle:"#8b4513"}
    });
    Composite.add(engine.world, ground);
  }

  async function spawn() {
    const idx = Math.floor(Math.random() * IMAGES.length);
    const tex = IMAGES[idx];
    const mask = MASKS[idx];

    const x = w/2;
    const y = render.bounds.min.y + 120;

    let body = await ShapeExtract.makeBody(tex, x, y, {
      maskPath: mask,
      targetSize: CFG.targetSize,
      hitInset: CFG.hitInset,
      shapeCfg: CFG.shape,
      bodyOpts: { label:"Pintxo" }
    });

    Body.setStatic(body, true);
    body.isDropped = false;
    current = body;
    Composite.add(engine.world, body);
    isDropping = false;

    if (debugOn) {
      const d = body.__dbg || {};
      dbgPanel.innerHTML =
        `<b>Spawn</b><br>` +
        `tex: ${short(tex)}<br>` +
        `mask: ${short(mask)}<br>` +
        `fallback: <b style="color:${d.usedFallback ? '#ff6666' : '#7CFF7C'}">${d.usedFallback}</b><br>` +
        `reason: ${escapeHtml(d.reason || "-")}<br>` +
        `verts: ${d.vertexCount} parts:${d.partsCount}<br>` +
        `solidRatio: ${d.solidRatio != null ? d.solidRatio.toFixed(3) : "-"}<br>` +
        `spriteScale: ${d.spriteScale?.toFixed(3)} hitInset:${d.hitInset}<br>` +
        `offset: (${(d.xOffset??0).toFixed(3)}, ${(d.yOffset??0).toFixed(3)})<br>` +
        `hasDecomp: ${d.hasDecomp}`;
      console.log("[DBG spawn]", d);
    }
  }

  function short(p){ return String(p).split("/").slice(-2).join("/"); }
  function escapeHtml(s){return String(s).replace(/[&<>"']/g,c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));}

  function move(dir) { if (current && !isDropping) Body.translate(current, { x: dir * CFG.moveStep, y: 0 }); }
  function rotate() { if (current && !isDropping) Body.rotate(current, CFG.rotateStep); }

  async function drop() {
    if (!current || isDropping) return;
    isDropping = true;

    Body.setStatic(current, false);
    current.isDropped = true;

    const dropped = current;
    await waitForSettle(dropped, CFG.settleMaxMs);

    if (!active) return;

    addScore(dropped);
    await spawn();
  }

  function waitForSettle(body, maxMs) {
    return new Promise((resolve) => {
      const t0 = performance.now();
      let stable = 0;
      const check = () => {
        const now = performance.now();
        const v = body.speed || 0;
        const av = Math.abs(body.angularVelocity || 0);
        if (v < 0.12 && av < 0.12) stable++; else stable = 0;
        if (stable >= 18) return resolve();
        if (now - t0 > maxMs) return resolve();
        requestAnimationFrame(check);
      };
      requestAnimationFrame(check);
    });
  }

  function addScore(body) {
    const diff = ground.position.y - body.bounds.min.y;
    if (diff > 0) {
      score += (Math.floor(diff / 10) + 10);
      document.getElementById("sv").textContent = score;
    }
  }

  function tick() {
    if (!active) return;

    const deadY = ground.position.y + (h * CFG.deadPad);
    const bodies = Composite.allBodies(engine.world);

    for (const b of bodies) {
      if (b.label === "Pintxo" && b.isDropped) {
        if (b.position.y > deadY) {
          // game over
          active = false;
          alert("GAME OVER");
          return;
        }
      }
    }
  }

  function drawDebug() {
    if (!debugOn) return;

    const ctx = render.context;
    const bodies = Composite.allBodies(engine.world);

    ctx.save();
    ctx.lineWidth = 2;

    for (const b of bodies) {
      if (b.label !== "Pintxo") continue;

      const d = b.__dbg || {};
      const verts = b.vertices || [];
      if (verts.length) {
        ctx.beginPath();
        ctx.moveTo(verts[0].x, verts[0].y);
        for (let i = 1; i < verts.length; i++) ctx.lineTo(verts[i].x, verts[i].y);
        ctx.closePath();

        // fallback or forcedRect -> red, normal poly -> green
        ctx.strokeStyle = (d.usedFallback || d.forcedRect) ? "rgba(255,60,60,0.95)" : "rgba(50,255,80,0.95)";
        ctx.stroke();
      }

      // AABB bounds (gray)
      const min = b.bounds.min, max = b.bounds.max;
      ctx.strokeStyle = "rgba(0,0,0,0.18)";
      ctx.strokeRect(min.x, min.y, max.x - min.x, max.y - min.y);

      // label
      ctx.fillStyle = "rgba(0,0,0,0.65)";
      ctx.font = "12px sans-serif";
      const tag = (d.usedFallback || d.forcedRect) ? `RECT/FALLBACK v=${d.vertexCount}` : `POLY v=${d.vertexCount}`;
      ctx.fillText(tag, b.position.x + 6, b.position.y - 6);
    }

    ctx.restore();
  }

  function bindControls() {
    const hold = (node, action) => {
      let t = null;
      const s = (e)=>{ e.preventDefault(); action(); t=setInterval(action, 50); };
      const e = (e)=>{ e.preventDefault(); if (t) clearInterval(t); t=null; };
      node.addEventListener("touchstart", s, { passive:false });
      node.addEventListener("touchend", e);
      node.addEventListener("touchcancel", e);
      node.addEventListener("mousedown", s);
      node.addEventListener("mouseup", e);
      node.addEventListener("mouseleave", e);
    };

    hold(document.getElementById("L"), ()=>move(-1));
    hold(document.getElementById("R"), ()=>move(+1));

    const rot = document.getElementById("Rot");
    rot.addEventListener("click", rotate);
    rot.addEventListener("touchstart", (e)=>{ e.preventDefault(); rotate(); }, { passive:false });

    const dr = document.getElementById("drop");
    dr.addEventListener("click", drop);
    dr.addEventListener("touchstart", (e)=>{ e.preventDefault(); drop(); }, { passive:false });
  }
})();
</script>
</body>
</html>

