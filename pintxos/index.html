<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Pintxos Tower</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <script src="shape-extract.js?v=9"></script>

  <style>
    body { margin:0; padding:0; overflow:hidden; background:#f2f2f2; font-family: system-ui, -apple-system, sans-serif; touch-action:none; }
    canvas { display:block; position:fixed; top:0; left:0; z-index:0; }

    #ui-layer { position:absolute; top:0; left:0; width:100%; height:100%; pointer-events:none; z-index:10; }
    #score-board { position:absolute; top:18px; left:18px; font-size:40px; font-weight:900; color:#333; text-shadow:2px 2px 0 #fff; letter-spacing:1px; }
    #score-board span { font-size:40px; }

    #controls {
      position:absolute; bottom:30px; left:0; width:100%;
      display:flex; justify-content:center; align-items:center; gap:22px;
      pointer-events:auto;
    }
    .control-btn {
      width:74px; height:74px;
      background: rgba(255,255,255,0.92);
      border: 2px solid #999;
      border-radius: 50%;
      font-size: 28px;
      display:flex; justify-content:center; align-items:center;
      box-shadow: 0 6px 10px rgba(0,0,0,0.18);
      user-select:none; -webkit-user-select:none;
    }
    .control-btn:active { transform: translateY(2px); background:#ddd; }

    #btn-drop{
      width:104px; height:104px;
      background:#ff4757; color:#fff; border:none;
      font-size:34px; box-shadow:0 10px 14px rgba(0,0,0,0.22);
    }

    .overlay {
      position:absolute; inset:0;
      background: rgba(255,255,255,0.95);
      display:flex; flex-direction:column; justify-content:center; align-items:center;
      z-index:20; pointer-events:auto;
    }
    .hidden { display:none !important; }

    button.primary-btn {
      padding: 14px 42px; font-size: 18px;
      background:#2ecc71; color:#fff; border:none; border-radius:30px;
      margin-top:14px; cursor:pointer;
    }

    #game-over-screen input {
      padding:10px; font-size:16px; text-align:center;
      border-radius:10px; border:1px solid #bbb; width:220px;
    }
    #ranking-list { padding:0; list-style:none; margin-top:10px; }
    #ranking-list li { margin:6px 0; border-bottom:1px solid #ddd; padding:6px; width:240px; display:flex; justify-content:space-between; }

    /* Debug UI */
    #dbgBtn{
      position:absolute; top:16px; right:16px; z-index:30;
      pointer-events:auto;
      background:#222; color:#fff; border:none; border-radius:22px;
      padding:10px 14px; display:flex; gap:10px; align-items:center;
      box-shadow: 0 8px 14px rgba(0,0,0,0.25);
      opacity:0.92;
    }
    #dbgPanel{
      position:absolute; top:70px; right:16px; z-index:30;
      pointer-events:none;
      background:rgba(20,20,20,0.86); color:#fff;
      padding:14px 16px; border-radius:16px;
      width:300px; font-size:14px; line-height:1.35;
      white-space:pre-wrap;
    }
  </style>
</head>

<body>
  <div id="ui-layer">
    <div id="score-board">SCORE: <span id="score-val">0</span></div>

    <div id="controls" class="hidden">
      <button class="control-btn" id="btn-left">‚¨ÖÔ∏è</button>
      <button class="control-btn" id="btn-rotate">üîÑ</button>
      <button class="control-btn" id="btn-right">‚û°Ô∏è</button>
      <button class="control-btn" id="btn-drop">‚¨áÔ∏è</button>
    </div>
  </div>

  <button id="dbgBtn">üêû <b>DEBUG</b></button>
  <div id="dbgPanel" class="hidden"></div>

  <div id="title-screen" class="overlay">
    <h1 style="margin:0 0 10px 0;">Pintxos Tower</h1>
    <p style="margin:0 0 10px 0;">ËêΩ„Å®„Åó„Å¶Á©ç„Åø‰∏ä„Åí„ÇçÔºÅ</p>
    <button class="primary-btn" id="btn-start">START</button>
  </div>

  <div id="game-over-screen" class="overlay hidden">
    <h1 style="margin:0 0 10px 0;">GAME OVER</h1>
    <p>Score: <span id="final-score">0</span></p>

    <div id="input-area">
      <input type="text" id="player-name" placeholder="ÂêçÂâç„ÇíÂÖ•Âäõ" maxlength="8">
      <br><br>
      <button class="primary-btn" id="btn-save">„É©„É≥„Ç≠„É≥„Ç∞ÁôªÈå≤</button>
      <br>
      <button style="margin-top:16px; background:none; border:none; text-decoration:underline; color:#666;" id="btn-retry">„É™„Éà„É©„Ç§</button>
    </div>

    <div id="ranking-area" class="hidden">
      <h3 style="margin:0 0 8px 0;">„É©„É≥„Ç≠„É≥„Ç∞</h3>
      <ul id="ranking-list"></ul>
      <button class="primary-btn" id="btn-again">„ÇÇ„ÅÜ‰∏ÄÂ∫¶</button>
    </div>
  </div>

<script>
(() => {
  const { Engine, Render, Runner, Bodies, Composite, Events, Body } = Matter;

  // ===== Ë®≠ÂÆöÔºà„Åì„Åì„Å†„ÅëËß¶„Çå„Å∞Ë™øÊï¥„Åß„Åç„ÇãÔºâ =====
  const IMG_COUNT = 11;
  const IMG_DIR = "img";
  const MASK_DIR = "mask";

  const PIECE_TARGET_SIZE = 150;    // Ë¶ã„ÅüÁõÆ„ÅÆ„Çµ„Ç§„Ç∫
  const HIT_INSET = 1.02;           // 1.0„Çà„ÇäÂ§ß„Åç„ÅÑÔºùÈöôÈñì„ÇíË©∞„ÇÅ„ÇãÔºàË©∞„ÇÅ„Åô„ÅéÊ≥®ÊÑèÔºâ
  const MOVE_STEP = 7;
  const ROT_STEP = Math.PI / 10;

  // „Äå‰∏ã„Å´Ê∂à„Åà„Åü„Çâ„Éü„Çπ„ÄçÂà§ÂÆöÔºö ground „Çà„Çä„Åì„Çå‰ª•‰∏ä‰∏ã„Å´ËêΩ„Å°„Åü„ÇâÁµÇ‰∫Ü
  const KILL_EXTRA = 1100;

  // ÂΩ¢ÊäΩÂá∫„ÅÆË®≠ÂÆöÔºà„Éû„Çπ„ÇØÂìÅË≥™„ÅßÂ§â„Åà„ÇãÔºâ
  const SHAPE_CFG = {
    alphaThreshold: 1,
    nPoints: 140,
    padPx: 2,
    analysisMax: 560,
    minContour: 24,
    erodePx: 0
  };

  // ===== UI =====
  const $ = (id) => document.getElementById(id);
  const scoreEl = $("score-val");
  const dbgBtn = $("dbgBtn");
  const dbgPanel = $("dbgPanel");

  const controls = $("controls");
  const btnL = $("btn-left");
  const btnR = $("btn-right");
  const btnRot = $("btn-rotate");
  const btnDrop = $("btn-drop");

  const titleScreen = $("title-screen");
  const gameOverScreen = $("game-over-screen");
  const finalScoreEl = $("final-score");
  const inputArea = $("input-area");
  const rankingArea = $("ranking-area");
  const rankingList = $("ranking-list");

  // ===== Áä∂ÊÖã =====
  let engine, render, runner;
  let ground;
  let w = innerWidth, h = innerHeight;

  let gameActive = false;
  let score = 0;

  let current = null;        // Êìç‰Ωú‰∏≠ÔºàstaticÔºâ
  let isDropping = false;    // dropÁõ¥Âæå„ÅÆÂæÖÊ©ü
  let spawning = false;

  let debugOn = false;
  let lastDbgText = "";

  const IMAGES = Array.from({length: IMG_COUNT}, (_,i)=> `${IMG_DIR}/${i+1}.png`);

  // ===== ÂàùÊúüÂåñ =====
  function init() {
    render = Render.create({
      element: document.body,
      engine: Engine.create(), // „ÉÄ„Éü„Éº
      options: {
        width: w,
        height: h,
        background: "#f2f2f2",
        wireframes: false,
        pixelRatio: 1
      }
    });
    Render.run(render);

    window.addEventListener("resize", onResize, { passive: true });

    // debug button
    dbgBtn.addEventListener("click", () => {
      debugOn = !debugOn;
      dbgPanel.classList.toggle("hidden", !debugOn);
    });

    // start
    $("btn-start").addEventListener("click", startGame);

    // ranking
    $("btn-save").addEventListener("click", saveScore);
    $("btn-retry").addEventListener("click", startGame);
    $("btn-again").addEventListener("click", startGame);

    // controls
    const hold = (btn, action) => {
      let t = null;
      const start = (e) => { e.preventDefault(); action(); t = setInterval(action, 50); };
      const end = (e) => { e.preventDefault(); if(t) clearInterval(t); t = null; };
      btn.addEventListener("touchstart", start, { passive: false });
      btn.addEventListener("touchend", end);
      btn.addEventListener("touchcancel", end);
      btn.addEventListener("mousedown", start);
      btn.addEventListener("mouseup", end);
      btn.addEventListener("mouseleave", end);
    };
    hold(btnL, ()=>move(-1));
    hold(btnR, ()=>move(1));
    btnRot.addEventListener("click", rotate);
    btnRot.addEventListener("touchstart", (e)=>{ e.preventDefault(); rotate(); }, { passive:false });
    btnDrop.addEventListener("click", drop);
    btnDrop.addEventListener("touchstart", (e)=>{ e.preventDefault(); drop(); }, { passive:false });

    // outline drawing
    Matter.Events.on(render, "afterRender", drawDebugOverlay);
  }

  function onResize() {
    w = innerWidth; h = innerHeight;
    render.canvas.width = w;
    render.canvas.height = h;
    render.options.width = w;
    render.options.height = h;
  }

  function resetPhysics() {
    if (runner) Runner.stop(runner);

    engine = Engine.create();
    engine.enableSleeping = true;
    engine.gravity.y = 1;

    render.engine = engine;

    runner = Runner.create();
    Runner.run(runner, engine);

    Events.on(engine, "beforeUpdate", updateLoop);
    createGround();
    Render.lookAt(render, { min:{x:0,y:0}, max:{x:w,y:h} });
  }

  function createGround() {
    const groundY = h - 180;
    const groundWidth = w * 0.38;
    ground = Bodies.rectangle(w/2, groundY, groundWidth, 20, {
      isStatic: true,
      label: "Ground",
      render: { fillStyle: "#8b4513" },
      friction: 1.0
    });
    Composite.add(engine.world, ground);
  }

  // ===== „Ç≤„Éº„É†Âà∂Âæ° =====
  async function startGame() {
    titleScreen.classList.add("hidden");
    gameOverScreen.classList.add("hidden");
    controls.classList.remove("hidden");

    score = 0;
    scoreEl.textContent = String(score);

    gameActive = true;
    current = null;
    isDropping = false;
    spawning = false;

    resetPhysics();

    await spawnPiece();
  }

  function getIdFromPath(texPath) {
    const m = texPath.match(/(\d+)\.png$/);
    return m ? m[1] : "1";
  }

  async function spawnPiece() {
    if (!gameActive || spawning) return;
    spawning = true;

    const tex = IMAGES[Math.floor(Math.random() * IMAGES.length)];
    const id = getIdFromPath(tex);
    const mask = `${MASK_DIR}/${id}.png`;

    const spawnY = render.bounds.min.y + 120;
    const spawnX = w / 2;

    try {
      const body = await ShapeExtract.makeBody(tex, spawnX, spawnY, {
        maskPath: mask,
        targetSize: PIECE_TARGET_SIZE,
        hitInset: HIT_INSET,
        shapeCfg: SHAPE_CFG,
        bodyOpts: { label:"Pintxo", restitution:0.02, friction:0.95 }
      });

      Body.setStatic(body, true);
      body.isDropped = false;

      Composite.add(engine.world, body);
      current = body;
      isDropping = false;

      updateDbgText(body);

    } catch (e) {
      console.error(e);
    } finally {
      spawning = false;
    }
  }

  function move(dir) {
    if (!current || isDropping) return;
    const nx = current.position.x + dir * MOVE_STEP;
    const margin = 40;
    if (nx < margin || nx > w - margin) return;
    Body.translate(current, { x: dir * MOVE_STEP, y: 0 });
  }

  function rotate() {
    if (!current || isDropping) return;
    Body.rotate(current, ROT_STEP);
  }

  function drop() {
    if (!current || isDropping) return;

    isDropping = true;
    const dropped = current;
    current = null;

    Body.setStatic(dropped, false);
    dropped.isDropped = true;

    waitUntilSettled(dropped).then(() => {
      if (!gameActive) return;
      addScoreFor(dropped);
      spawnPiece();
    });
  }

  function waitUntilSettled(body) {
    return new Promise((resolve) => {
      let stable = 0;
      const need = 18;

      const handler = () => {
        if (!gameActive) { Events.off(engine, "afterUpdate", handler); resolve(); return; }
        if (!body || body.isStatic) { Events.off(engine, "afterUpdate", handler); resolve(); return; }

        const speed = body.speed;
        const ang = Math.abs(body.angularVelocity);

        // Áú†„Çã or „Åª„ÅºÂÅúÊ≠¢„ÅåÈÄ£Á∂ö
        if (body.isSleeping || (speed < 0.12 && ang < 0.12)) stable++;
        else stable = 0;

        if (stable >= need) {
          Events.off(engine, "afterUpdate", handler);
          resolve();
        }
      };

      Events.on(engine, "afterUpdate", handler);
    });
  }

  function addScoreFor(body) {
    const diff = ground.position.y - body.position.y;
    if (diff > 0) {
      score += (Math.floor(diff / 10) + 10);
      scoreEl.textContent = String(score);
    }
  }

  function gameOver() {
    gameActive = false;
    controls.classList.add("hidden");
    finalScoreEl.textContent = String(score);
    gameOverScreen.classList.remove("hidden");
    inputArea.classList.remove("hidden");
    rankingArea.classList.add("hidden");
  }

  // ===== „Ç´„É°„É© + „Éü„ÇπÂà§ÂÆö =====
  function updateLoop() {
    if (!gameActive) return;

    const allBodies = Composite.allBodies(engine.world);

    // camera follow: ‰∏ÄÁï™È´ò„ÅÑ„Éî„Éº„Çπ„ÇíËøΩ„ÅÜ
    let highestY = ground.position.y;
    let hasStack = false;

    for (const b of allBodies) {
      if (b.label === "Pintxo" && b.isDropped) {
        if (b.position.y < highestY) {
          highestY = b.position.y;
          hasStack = true;
        }
      }
    }

    let targetTopY = 0;
    if (hasStack) targetTopY = highestY - (h * 0.55);
    if (targetTopY > 0) targetTopY = 0;

    const curTop = render.bounds.min.y;
    if (targetTopY < curTop) {
      const newY = curTop + (targetTopY - curTop) * 0.06;
      Render.lookAt(render, { min:{x:0,y:newY}, max:{x:w,y:newY+h} });
    } else if (curTop < 0 && !hasStack) {
      Render.lookAt(render, { min:{x:0,y:0}, max:{x:w,y:h} });
    }

    // „Äå‰∏ã„Å´Ê∂à„Åà„Åü„Çâ„Éü„Çπ„ÄçÔºö ground „Çà„Çä‰∏ÄÂÆö‰ª•‰∏ä‰∏ã„Å´ËêΩ„Å°„Åü„ÇâÁµÇ‰∫Ü
    const killY = ground.position.y + KILL_EXTRA;

    for (const b of allBodies) {
      if (b.label === "Pintxo" && b.isDropped) {
        if (b.position.y > killY) {
          gameOver();
          break;
        }
      }
    }

    // debug
    if (debugOn) {
      const last = (current || allBodies.find(b => b.label==="Pintxo" && b.isDropped));
      if (last) updateDbgText(last);
    }
  }

  // ===== „É©„É≥„Ç≠„É≥„Ç∞ =====
  function saveScore() {
    const name = ($("player-name").value || "ÂêçÁÑ°„Åó").slice(0, 8);
    const key = "pintxosRank";
    const data = JSON.parse(localStorage.getItem(key) || "[]");
    data.push({ name, score });
    data.sort((a,b)=> b.score - a.score);
    localStorage.setItem(key, JSON.stringify(data.slice(0, 5)));
    showRank();
  }

  function showRank() {
    const data = JSON.parse(localStorage.getItem("pintxosRank") || "[]");
    rankingList.innerHTML = "";
    data.forEach((d, i) => {
      const li = document.createElement("li");
      li.innerHTML = `<span>${i+1}. ${d.name}</span><span>${d.score}</span>`;
      rankingList.appendChild(li);
    });
    inputArea.classList.add("hidden");
    rankingArea.classList.remove("hidden");
  }

  // ===== DEBUG Ë°®Á§∫Ôºàundefined„Å´„Åó„Å™„ÅÑÔºâ =====
  function updateDbgText(body) {
    const spr = body?.render?.sprite || {};
    const dbg = body.__dbg || {};
    const verts = body.vertices?.length ?? 0;
    const parts = body.parts?.length ?? 0;

    const txt =
`Spawn
tex: ${dbg.tex || spr.texture || "-"}
mask: ${dbg.mask || "-"}
ShapeExtract: ${window.ShapeExtract?.VERSION || "MISSING"}

fallback: ${dbg.fallbackBool === true ? "true" : (dbg.fallbackBool === false ? "false" : "unknown")}
reason: ${dbg.reason || "-"}
verts: ${verts}  parts:${parts}
solidRatio: ${(dbg.solidRatio ?? 0).toFixed ? (dbg.solidRatio).toFixed(3) : dbg.solidRatio}
spriteScale: ${(dbg.spriteScale ?? 0).toFixed ? (dbg.spriteScale).toFixed(3) : dbg.spriteScale}  hitInset:${dbg.hitInset ?? "-"}
offset: (${(spr.xOffset ?? 0.5).toFixed(3)}, ${(spr.yOffset ?? 0.5).toFixed(3)})
forcedRect: ${dbg.forcedRect ? "true" : "false"}
meta: ${dbg.meta ? JSON.stringify(dbg.meta) : "-"}`;

    lastDbgText = txt;
    dbgPanel.textContent = txt;
  }

  // ===== ÂΩì„Åü„ÇäÂà§ÂÆöÂèØË¶ñÂåñÔºàÁ∑ë„É©„Ç§„É≥/Ëµ§Â°ó„ÇäÔºâ =====
  function toCanvas(v) {
    const bounds = render.bounds;
    const cw = render.options.width;
    const ch = render.options.height;
    const sx = cw / (bounds.max.x - bounds.min.x);
    const sy = ch / (bounds.max.y - bounds.min.y);
    return {
      x: (v.x - bounds.min.x) * sx,
      y: (v.y - bounds.min.y) * sy
    };
  }

  function drawPoly(ctx, body, fill, stroke) {
    const verts = body.vertices;
    if (!verts || verts.length < 3) return;

    ctx.beginPath();
    const p0 = toCanvas(verts[0]);
    ctx.moveTo(p0.x, p0.y);
    for (let i=1;i<verts.length;i++){
      const p = toCanvas(verts[i]);
      ctx.lineTo(p.x, p.y);
    }
    ctx.closePath();

    if (fill) { ctx.fillStyle = fill; ctx.fill(); }
    if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = 3; ctx.stroke(); }
  }

  function drawDebugOverlay() {
    if (!debugOn) return;
    const ctx = render.context;
    const bodies = Composite.allBodies(engine.world);
    const target = current || bodies.find(b => b.label==="Pintxo" && b.isDropped);
    if (!target) return;

    // bbox
    const b = target.bounds;
    const a = toCanvas({x:b.min.x,y:b.min.y});
    const c = toCanvas({x:b.max.x,y:b.max.y});
    ctx.save();
    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    ctx.lineWidth = 2;
    ctx.strokeRect(a.x, a.y, c.x - a.x, c.y - a.y);

    // polygon
    drawPoly(ctx, target, "rgba(255,0,0,0.35)", "rgba(0,255,0,0.9)");

    // label
    const isRect = !!target.__dbg?.forcedRect;
    const label = isRect ? "RECT" : `POLY v=${target.vertices?.length ?? 0}`;
    const pos = toCanvas(target.position);
    ctx.fillStyle = "rgba(0,0,0,0.55)";
    ctx.font = "16px system-ui";
    ctx.fillText(label, pos.x - 30, pos.y);

    ctx.restore();
  }

  // ===== Ëµ∑Âãï =====
  init();
})();
</script>
</body>
</html>
