<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>ã‚¿ãƒ¯ãƒ¼ãƒãƒˆãƒ«</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/poly-decomp@0.3.0/build/decomp.min.js"></script>
  <script src="./shape-extract.js"></script>
  <style>
    body { margin:0; padding:0; overflow:hidden; background:#f3f3f3; font-family: system-ui, -apple-system, sans-serif; touch-action:none; }
    canvas { display:block; position:fixed; inset:0; z-index:0; }
    #ui { position:absolute; inset:0; z-index:10; pointer-events:none; }
    #score { position:absolute; top:18px; left:18px; font-weight:900; font-size:44px; color:#222; text-shadow:2px 2px 0 #fff; }
    #controls { position:absolute; left:0; right:0; bottom:28px; height:110px; display:flex; justify-content:center; align-items:center; gap:22px; pointer-events:auto; }
    .btn {
      width:86px; height:86px; border-radius:50%;
      background:rgba(255,255,255,.95);
      border:4px solid rgba(0,0,0,.25);
      box-shadow:0 10px 18px rgba(0,0,0,.18);
      font-size:34px; display:flex; justify-content:center; align-items:center;
      user-select:none; -webkit-user-select:none;
    }
    .btn:active { transform:translateY(2px); filter:brightness(.95); }
    #drop { width:110px; height:110px; background:#ff4d5a; color:#fff; border:none; border-radius:50%; font-size:40px; }
    .overlay { position:absolute; inset:0; background:rgba(255,255,255,.96); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:20; pointer-events:auto; }
    .hidden { display:none !important; }
    .primary { padding:14px 34px; font-size:18px; border:none; border-radius:999px; background:#2ecc71; color:#fff; margin-top:14px; }
    #ranking { list-style:none; padding:0; margin:10px 0 0 0; width:260px; }
    #ranking li { display:flex; justify-content:space-between; padding:8px 6px; border-bottom:1px solid #ddd; }
    input { padding:10px; font-size:16px; text-align:center; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="score">SCORE: <span id="sv">0</span></div>
    <div id="controls" class="hidden">
      <div class="btn" id="L">â¬…ï¸</div>
      <div class="btn" id="R0">ğŸ”„</div>
      <div class="btn" id="R">â¡ï¸</div>
      <button id="drop">â¬‡ï¸</button>
    </div>
  </div>

  <div id="title" class="overlay">
    <h1 style="margin:0 0 8px 0;">ã‚¿ãƒ¯ãƒ¼ãƒãƒˆãƒ«</h1>
    <div style="opacity:.75; margin-bottom:12px;">ãƒ”ãƒ³ãƒãƒ§ã‚¹ã‚’ç©ã‚ã€‚è½ã¨ã—ãŸã‚‰è² ã‘ã€‚</div>
    <button class="primary" id="start">START</button>
  </div>

  <div id="over" class="overlay hidden">
    <h1 style="margin:0 0 6px 0;">GAME OVER</h1>
    <div style="margin-bottom:10px;">Score: <span id="fs">0</span></div>

    <div id="inputArea">
      <input id="name" maxlength="8" placeholder="åå‰" />
      <div><button class="primary" id="save">ãƒ©ãƒ³ã‚­ãƒ³ã‚°ç™»éŒ²</button></div>
      <button style="margin-top:14px; background:none; border:none; text-decoration:underline; color:#666;" id="retry">ãƒªãƒˆãƒ©ã‚¤</button>
    </div>

    <div id="rankArea" class="hidden">
      <h3 style="margin:0 0 6px 0;">ãƒ©ãƒ³ã‚­ãƒ³ã‚°</h3>
      <ul id="ranking"></ul>
      <button class="primary" id="again">ã‚‚ã†ä¸€åº¦</button>
    </div>
  </div>

<script>
(() => {
  const Engine = Matter.Engine, Render = Matter.Render, Runner = Matter.Runner;
  const Bodies = Matter.Bodies, Composite = Matter.Composite, Events = Matter.Events, Body = Matter.Body;

  // ===== è¨­å®šï¼ˆã“ã“ã ã‘è§¦ã‚Œã°èª¿æ•´ã§ãã‚‹ï¼‰ =====
  const CFG = {
    count: 11,
    texDir: "./img/",
    maskDir: "./mask/",
    targetSize: 150,         // è¦‹ãŸç›®ã‚µã‚¤ã‚ºåŸºæº–
    hitInset: 0.97,          // éš™é–“ã‚’è©°ã‚ã‚‹ãªã‚‰ 0.95ã€œ0.99
    shape: { threshold: 5, sampleScale: 0.5, nPoints: 180 }, // ãƒã‚¹ã‚¯å‘ã‘
    ground: { yPad: 190, wRatio: 0.32, h: 22 },
    moveStep: 7,
    rotateStep: Math.PI / 6,
    deadPad: 1.35,           // ç”»é¢ä¸‹ã«è½ã¡ãŸã‚‰è² ã‘ã®ãƒ©ã‚¤ãƒ³å€ç‡
    settleMaxMs: 2200,       // è½ä¸‹å¾Œã®å¾…ã¡æ™‚é–“ä¸Šé™
  };

  const IMAGES = Array.from({length: CFG.count}, (_,i)=> `${CFG.texDir}${i+1}.png`);
  const MASKS  = Array.from({length: CFG.count}, (_,i)=> `${CFG.maskDir}${i+1}.png`);

  // ===== çŠ¶æ…‹ =====
  let engine, render, runner;
  let w = innerWidth, h = innerHeight;
  let ground = null;
  let current = null;
  let isDropping = false;
  let active = false;
  let score = 0;

  // ===== UI =====
  const el = (id)=>document.getElementById(id);
  const sv = el("sv"), fs = el("fs");
  const title = el("title"), over = el("over");
  const controls = el("controls");
  const inputArea = el("inputArea"), rankArea = el("rankArea");

  // ===== åˆæœŸåŒ– =====
  window.addEventListener("load", init);
  function init() {
    // decompã‚»ãƒƒãƒˆï¼ˆfromVerticeså®‰å®šåŒ–ï¼‰
    try { Matter.Common.setDecomp(decomp); } catch (_) {}

    engine = Engine.create();
    render = Render.create({
      element: document.body,
      engine,
      options: { width:w, height:h, wireframes:false, background:"#f3f3f3", pixelRatio:1 }
    });
    Render.run(render);
    runner = Runner.create();
    Runner.run(runner, engine);

    createGround();
    Events.on(engine, "beforeUpdate", tick);

    window.addEventListener("resize", () => {
      w = innerWidth; h = innerHeight;
      render.canvas.width = w; render.canvas.height = h;
    });

    // buttons
    el("start").onclick = start;
    el("retry").onclick = start;
    el("again").onclick = start;
    el("save").onclick = saveScore;

    bindControls();
  }

  function createGround() {
    if (ground) Composite.remove(engine.world, ground);
    const gy = h - CFG.ground.yPad;
    const gw = w * CFG.ground.wRatio;
    ground = Bodies.rectangle(w/2, gy, gw, CFG.ground.h, {
      isStatic:true, label:"Ground",
      friction: 1.0,
      render: { fillStyle:"#8b4513" }
    });
    Composite.add(engine.world, ground);
  }

  function resetWorld() {
    Composite.clear(engine.world, false);
    Engine.clear(engine);
    createGround();
    Render.lookAt(render, { min:{x:0,y:0}, max:{x:w,y:h} });
  }

  async function start() {
    title.classList.add("hidden");
    over.classList.add("hidden");
    controls.classList.remove("hidden");
    inputArea.classList.remove("hidden");
    rankArea.classList.add("hidden");

    w = innerWidth; h = innerHeight;
    render.canvas.width = w; render.canvas.height = h;

    resetWorld();

    score = 0; sv.textContent = score;
    active = true;
    isDropping = false;
    current = null;

    await spawn();
  }

  async function spawn() {
    if (!active) return;

    const idx = Math.floor(Math.random() * IMAGES.length);
    const tex = IMAGES[idx];
    const mask = MASKS[idx];

    const x = w/2;
    const y = render.bounds.min.y + 120;

    let body;
    try {
      body = await ShapeExtract.makeBody(tex, x, y, {
        maskPath: mask,
        targetSize: CFG.targetSize,
        hitInset: CFG.hitInset,
        shapeCfg: CFG.shape,
        bodyOpts: { label:"Pintxo" }
      });
    } catch (e) {
      console.warn("spawn failed -> rectangle fallback", e);
      body = Bodies.rectangle(x, y, CFG.targetSize, CFG.targetSize, { label:"Pintxo" });
    }

    Body.setStatic(body, true);
    body.isDropped = false;
    current = body;
    Composite.add(engine.world, body);
    isDropping = false;
  }

  function move(dir) {
    if (current && !isDropping) Body.translate(current, { x: dir * CFG.moveStep, y: 0 });
  }
  function rotate() {
    if (current && !isDropping) Body.rotate(current, CFG.rotateStep);
  }

  async function drop() {
    if (!current || isDropping) return;
    isDropping = true;

    Body.setStatic(current, false);
    current.isDropped = true;

    const dropped = current;

    // è½ä¸‹ãŒè½ã¡ç€ãã¾ã§å¾…ã£ã¦ã‹ã‚‰ã‚¹ã‚³ã‚¢ï¼†æ¬¡ã‚¹ãƒãƒ¼ãƒ³
    await waitForSettle(dropped, CFG.settleMaxMs);

    if (!active) return;
    addScore(dropped);
    await spawn();
  }

  function waitForSettle(body, maxMs) {
    return new Promise((resolve) => {
      const t0 = performance.now();
      let stable = 0;

      const check = () => {
        if (!active) return resolve();
        const now = performance.now();
        const v = body.speed || 0;
        const av = Math.abs(body.angularVelocity || 0);

        if (v < 0.12 && av < 0.12) stable++;
        else stable = 0;

        if (stable >= 18) return resolve(); // 18ãƒ•ãƒ¬ãƒ¼ãƒ å®‰å®š
        if (now - t0 > maxMs) return resolve(); // ä¸Šé™
        requestAnimationFrame(check);
      };
      requestAnimationFrame(check);
    });
  }

  function addScore(body) {
    // ä¸Šç«¯åŸºæº–ï¼ˆè¦‹ãŸç›®ã«è¿‘ã„ï¼‰
    const diff = ground.position.y - body.bounds.min.y;
    if (diff > 0) {
      score += (Math.floor(diff / 10) + 10);
      sv.textContent = score;
    }
  }

  function tick() {
    if (!active) return;

    // è½ä¸‹ãƒŸã‚¹åˆ¤å®šï¼šåœ°é¢ã‚ˆã‚Šä¸€å®šä»¥ä¸Šä¸‹ã«è¡Œã£ãŸã‚‰çµ‚äº†
    const deadY = ground.position.y + (h * CFG.deadPad);

    const bodies = Composite.allBodies(engine.world);
    for (const b of bodies) {
      if (b.label === "Pintxo" && b.isDropped) {
        if (b.position.y > deadY) {
          gameOver();
          return;
        }
      }
    }

    // ã‚«ãƒ¡ãƒ©ï¼šæœ€ä¸Šæ®µã«è¿½å¾“ï¼ˆç©ã¿ä¸Šã’æ™‚ã®ã¿ï¼‰
    let top = ground.position.y;
    let has = false;
    for (const b of bodies) {
      if (b.label === "Pintxo" && b !== current) {
        if (b.bounds.min.y < top) { top = b.bounds.min.y; has = true; }
      }
    }
    if (has) {
      const targetTop = Math.min(0, top - h * 0.55);
      const curTop = render.bounds.min.y;
      const newTop = curTop + (targetTop - curTop) * 0.06;
      Render.lookAt(render, { min:{x:0,y:newTop}, max:{x:w,y:newTop+h} });
    } else if (render.bounds.min.y < 0) {
      Render.lookAt(render, { min:{x:0,y:0}, max:{x:w,y:h} });
    }
  }

  function gameOver() {
    active = false;
    controls.classList.add("hidden");
    over.classList.remove("hidden");
    fs.textContent = score;
  }

  function saveScore() {
    const name = (el("name").value || "åç„¡ã—").slice(0,8);
    const key = "towerbattle_rank";
    const arr = JSON.parse(localStorage.getItem(key) || "[]");
    arr.push({ name, score, t: Date.now() });
    arr.sort((a,b)=> b.score - a.score);
    localStorage.setItem(key, JSON.stringify(arr.slice(0,10)));
    showRank();
  }

  function showRank() {
    const key = "towerbattle_rank";
    const arr = JSON.parse(localStorage.getItem(key) || "[]");
    const ul = el("ranking");
    ul.innerHTML = "";
    arr.forEach((d,i)=>{
      const li = document.createElement("li");
      li.innerHTML = `<span>${i+1}. ${escapeHtml(d.name)}</span><span>${d.score}</span>`;
      ul.appendChild(li);
    });
    inputArea.classList.add("hidden");
    rankArea.classList.remove("hidden");
  }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  function bindControls() {
    const hold = (node, action) => {
      let t = null;
      const start = (e)=>{ e.preventDefault(); action(); t=setInterval(action, 50); };
      const end   = (e)=>{ e.preventDefault(); if (t) clearInterval(t); t=null; };
      node.addEventListener("touchstart", start, { passive:false });
      node.addEventListener("touchend", end);
      node.addEventListener("touchcancel", end);
      node.addEventListener("mousedown", start);
      node.addEventListener("mouseup", end);
      node.addEventListener("mouseleave", end);
    };

    hold(el("L"), ()=>move(-1));
    hold(el("R"), ()=>move(+1));
    el("R0").addEventListener("click", rotate);
    el("R0").addEventListener("touchstart", (e)=>{ e.preventDefault(); rotate(); }, { passive:false });

    el("drop").addEventListener("click", drop);
    el("drop").addEventListener("touchstart", (e)=>{ e.preventDefault(); drop(); }, { passive:false });
  }

})();
</script>
</body>
</html>
